<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nemiro.Data</name>
    </assembly>
    <members>
        <member name="T:Nemiro.Data.TableAttribute">
            <summary>
            Атрибут указывает, что класс реализует таблицу базы данных.
            </summary>
            <remarks>
            <para>Данным атрибутом помечаются классы наследованные от <see cref="T:Nemiro.Data.Sql.BaseObject"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.TableAttribute.#ctor(System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.TableAttribute"/> с указанием имени таблицы.
            </summary>
            <param name="tableName">Имя таблицы, которая реализована в классе.</param>
        </member>
        <member name="M:Nemiro.Data.TableAttribute.#ctor(System.String,System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.TableAttribute"/> с указанием имени таблицы и строкой соединения с базой данных.
            </summary>
            <param name="tableName">Имя таблицы, которая реализована в классе.</param>
            <param name="connectionString">Строка соединения с базой данных, либо имя параметра строки соединения в файле конфигурации приложения.</param>
        </member>
        <member name="P:Nemiro.Data.TableAttribute.TableName">
            <summary>
            Имя таблицы, которая реализована в классе.
            </summary>
        </member>
        <member name="P:Nemiro.Data.TableAttribute.ConnectionString">
            <summary>
            Строка соединения с БД (опционально).
            </summary>
        </member>
        <member name="T:Nemiro.Data.Sql.SqlClient">
            <summary>
            Основной класс для работы с базами данных SQL Server.
            </summary>
            <remarks>
            <para>По умолчанию, при инициализации класса используются параметры из файла конфигурации.
            Для web-проектов - <c>web.config</c>; для windows-приложений - <c>app.config</c>.</para>
            <para>Поддерживаются следующие параметры:
            <list type="bullet">
            <item><description>NeData:Sql:ConnectionMode</description></item>
            <item><description>NeData:Sql:CommandType</description></item>
            <item><description>NeData:Sql:CacheType</description></item>
            <item><description>NeData:Sql:CacheDuration (не рекомендуется использовать для установки глобального времени кэширования)</description></item>
            <item><description>NeData:Sql:CachePath</description></item>
            <item><description>NeData:Sql:CacheBufferSize</description></item>
            <item><description>NeData:Sql:CacheCustom</description></item>
            <item><description>NeData:Sql:CacheCustomArgs</description></item>
            </list>
            </para>
            <para>В приложениях Windows имена параметров нужно записывать без двоеточий и с учетом регистра.
            Например: 
            <list type="bullet">
            <item><description>NeDataSqlCacheTyp</description></item>
            <item><description>NeDataSqlAutoTrimmingStrings</description></item>
            <item><description>NeDataSqlCachePath</description></item>
            <item><description>и т.п.</description></item>
            </list>
            </para>
            <para>
            По умолчанию используется строка соединения <c>LocalSqlServer</c>.
            В качестве <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/> можно указывать, как саму строку соединения, так и имя параметра в файле конфигурации.
            В web-приложениях строка соединения с именем <c>LocalSqlServer</c> иметь путь к SQL Server по умолчанию. 
            Для использования параметра <c>LocalSqlServer</c> в веб-приложениях со своей базой данных, которая отличается от базы по умолчанию,
            необходимо удалить <c>LocalSqlServer</c> из файла конфигурации и добавить заново (написать код удаления и добавления):
            </para>
            <code lang="XML">
            &lt;remove name="LocalSqlServer"/&gt;
            &lt;add 
              name="LocalSqlServer" 
              connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
            /&gt;
            </code>
            <para>При работе с классом <see cref="T:Nemiro.Data.Sql.SqlClient"/> рекомендуется использовать оператор <c>using</c> .</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // код работы с данными
            }
            </code>
            <code lang="VB">
            Using client As new SqlClient()
              ' код работы с данными
            End Using
            </code>
            </remarks>
            <example>
            <list type="table">
            <listheader>
            <description>Обратите внимание</description>
            </listheader>
            <item>
            <description>Показанные ниже примеры лишь демонстрируют использование класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> и содержат строки соединения с базой данных, а также и SQL-запросы. У вас все эти данные могут отличаться. Пожалуйста, учитывайте этот факт и не забудьте поменять строки соединения и запросы на свои, если захотите проверить работу представленных фрагментов кода.</description>
            </item>
            </list>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с использованием строки соединения по умолчанию (<c>LocalSqlServer</c>).</para>
            <para>При помощи метода <see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/> выполняется SQL-запрос и в переменную <c>row</c> передается строка данных.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              DataRow row = client.GetRow("SELECT * FROM table WHERE id = 1000");
              if(row == null)
              {
                Console.WriteLine("Запрос не дал результатов");
              }
              else
              {
                Console.WriteLine("id = {0}", row["id"]);
              }
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              Dim row As DataRow = client.GetRow("SELECT * FROM table WHERE id = 1000")
              If row Is Nothing Then
                Console.WriteLine("Запрос не дал результатов")
              Else
                Console.WriteLine("id = {0}", row("id"))
              End If
            End Using
            </code>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с явным указанием строки соединения.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient(@"Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"))
            {
              DataRow row = client.GetRow("SELECT * FROM table WHERE id = 1000");
              if(row == null)
              {
                Console.WriteLine("Запрос не дал результатов");
              }
              else
              {
                Console.WriteLine("id = {0}", row["id"]);
              }
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient("Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;")
              Dim row As DataRow = client.GetRow("SELECT * FROM table WHERE id = 1000")
              If row Is Nothing Then
                Console.WriteLine("Запрос не дал результатов")
              Else
                Console.WriteLine("id = {0}", row("id"))
              End If
            End Using
            </code>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием имени параметра строки соединения в файле конфигурации.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient("MyConnectionString"))
            {
              DataRow row = client.GetRow("SELECT * FROM table WHERE id = 1000");
              if(row == null)
              {
                Console.WriteLine("Запрос не дал результатов");
              }
              else
              {
                Console.WriteLine("id = {0}", row["id"]);
              }
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient("MyConnectionString")
              Dim row As DataRow = client.GetRow("SELECT * FROM table WHERE id = 1000")
              If row Is Nothing Then
                Console.WriteLine("Запрос не дал результатов")
              Else
                Console.WriteLine("id = {0}", row("id"))
              End If
            End Using
            </code>
            <para>В следующем примере показано применение встроенного механизма кэширования.
            Данные кэшируются в файловой системе, по умолчанию в одном каталоге с программой.
            Продолжительность кэширования указывается в свойстве <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>.
            После выполнения запроса, в свойстве <see cref="P:Nemiro.Data.Sql.SqlClient.LastQueryTime"/> можно получить информацию о продолжительности выполнения последнего запроса.
            При помощи свойства <see cref="P:Nemiro.Data.Sql.SqlClient.LastQueryResultsFromCache"/> можно узнать, был ли использован кэш при выполнении последнего запроса или нет.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 30 секунд
              client.CacheDuration = 30;
              client.CacheType = CachingType.File;
              // формирование запроса
              client.CommandText = "SELECT * FROM table";
              // выполнение запроса
              DataTable table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
              // повторное выполнение аналогичного запроса
              table = client.GetTable();
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 30 секунд
              client.CacheDuration = 30
              client.CacheType = CachingType.File
              ' формирование запроса
              client.CommandText = "SELECT * FROM test"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
              ' повторное выполнение аналогичного запроса
              table = client.GetTable()
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> со значениями по умолчанию.
            </summary>
            <example>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с параметрами по умолчанию.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // ...
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              '...
            End Using
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием строки соединения с базой данных.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
            <example>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием имени параметра в файле конфигурации, который содержит строку соединения с SQL Server.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient("MyConnectionString"))
            {
              // ...
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient("MyConnectionString")
              '...
            End Using
            </code>
            <para>Ниже показан фрагмент файла <c>web.config</c> (приложения ASP .NET), который содержит строку соединения с именем <c>MyConnectionString</c>.</para>
            <code lang="XML">
            &lt;configuration&gt;
              &lt;connectionStrings&gt;
                &lt;add 
                  name="LocalSqlServer" 
                  connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
                /&gt;
              &lt;/connectionStrings&gt;
            &lt;/configuration&gt;
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.String,System.Int32)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием строки соединения с базой данных и времени кэширования результатов выполнения запросов.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один - без кэширования. Ноль - использовать значение и файла конфигурации, параметр <c>NeData:Sql:CacheDuration</c>.</param>
            <example>
            <para>В следующем примере создается экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием строки соединения и времени кэширования результатов выполнения запроса.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient(@"Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;", 300))
            {
              // ...
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient("Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;", 300)
              '...
            End Using
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.String,System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием строки соединения с базой данных и пути хранения записей кэша в файловой системе.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
            <param name="cachePath">Путь к каталогу хранения файлового кэша. Используется только для <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> = <see cref="F:Nemiro.Data.CachingType.File"/>. Если тип кэширования установлен Auto и будет указан cachePath, то данные будут кэшироваться в указанном каталоге. Значение по умолчанию берется из параметра <c>NeData:Sql:CachePath</c> файла конфигурации.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.String,System.Type,System.Object[])">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием строки соединения с базой данных и параметрами пользовательской системы кэширования результатов выполнения запросов.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
            <param name="cacheCustom">Тип пользовательского объекта кэширования (должен происходить от <see cref="T:System.Runtime.Caching.ObjectCache"/>). Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustom</c> файла конфигурации.</param>
            <param name="cacheCustomArgs">Дополнительные параметры инициализации пользовательского кэша, будут переданы в конструктор. Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustomArgs</c> файла конфигурации.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.Type,System.Object[])">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием параметров пользовательской системы кэширования результатов выполнения запросов к базе данных.
            </summary>
            <param name="cacheCustom">Тип пользовательского объекта кэширования (должен происходить от <see cref="T:System.Runtime.Caching.ObjectCache"/>). Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustom</c> файла конфигурации.</param>
            <param name="cacheCustomArgs">Дополнительные параметры инициализации пользовательского кэша, будут переданы в конструктор. Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustomArgs</c> файла конфигурации.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.Type,System.Object[],System.Int32)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/>.
            </summary>
            <param name="cacheCustom">Тип пользовательского объекта кэширования (должен происходить от <see cref="T:System.Runtime.Caching.ObjectCache"/>). Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustom</c> файла конфигурации.</param>
            <param name="cacheCustomArgs">Дополнительные параметры инициализации пользовательского кэша, будут переданы в конструктор. Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustomArgs</c> файла конфигурации.</param>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один - без кэширования. Ноль - использовать значение и файла конфигурации, параметр <c>NeData:Sql:CacheDuration</c>.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.Type,System.Int32)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием параметров пользовательской системы кэширования результатов выполнения запросов к базе данных и продолжительности кэширования данных.
            </summary>
            <param name="cacheCustom">Тип пользовательского объекта кэширования (должен происходить от <see cref="T:System.Runtime.Caching.ObjectCache"/>). Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustom</c> файла конфигурации.</param>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один - без кэширования. Ноль - использовать значение и файла конфигурации, параметр <c>NeData:Sql:CacheDuration</c>.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.Int32)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием продолжительности кэширования результатов выполнения запросов к базе данных.
            </summary>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один - без кэширования. Ноль - использовать значение и файла конфигурации, параметр <c>NeData:Sql:CacheDuration</c>.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.#ctor(System.String,System.Int32,System.String,System.Type,System.Object[])">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> с указанием основных параметров конфигурации класса.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один - без кэширования. Ноль - использовать значение и файла конфигурации, параметр <c>NeData:Sql:CacheDuration</c>.</param>
            <param name="cachePath">Путь к каталогу хранения файлового кэша. Используется только для <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> = <see cref="F:Nemiro.Data.CachingType.File"/>. Если тип кэширования установлен Auto и будет указан cachePath, то данные будут кэшироваться в указанном каталоге. Значение по умолчанию берется из параметра <c>NeData:Sql:CachePath</c> файла конфигурации.</param>
            <param name="cacheCustom">Тип пользовательского объекта кэширования (должен происходить от <see cref="T:System.Runtime.Caching.ObjectCache"/>). Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustom</c> файла конфигурации.</param>
            <param name="cacheCustomArgs">Дополнительные параметры инициализации пользовательского кэша, будут переданы в конструктор. Значение по умолчанию берется из параметра <c>NeData:Sql:CacheCustomArgs</c> файла конфигурации.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.Dispose">
            <summary>
            Освобождает все ресерсу, занятые объектом.
            Если необходимо, закрывает все открытые объектом соединения с базой данных.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetData">
            <summary>
            Выполняет запрос и возвращает <see cref="T:System.Data.DataSet"/>.
            Данный метод используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает <see cref="T:System.Data.DataSet"/>, содержащий результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустой <see cref="T:System.Data.DataSet"/>.</para>
            </returns>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос
              c.CommandText = "SELECT * FROM messages; SELECT * FROM users;";
              // выполняем запрос
              DataSet data = c.GetData();
              if(data.Tables.Count &gt; 0)
              {
                // есть данные, выводим в консоль
                foreach(DataTable t in data.Tables)
                {
                  foreach(DataRow r in table.Rows)
                  {
                    Console.WriteLine("id = {0}", r["id"]);
                  }
                }
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              c.CommandText = "SELECT * FROM messages; SELECT * FROM users;"
              ' выполняем запрос
              Dim data As DataSet = c.GetData()
              If data.Tables.Count &gt; 0 Then
                ' есть данные, выводим в консоль
                For Each t As DataTable In data.Tables
                  For Each r As DataRow In table.Rows
                    Console.WriteLine("id = {0}", r("id"))
                  Next
                Next
              End If
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetData(System.String)">
            <summary>
            Выполняет указанную SQL-инструкцию и возвращает <see cref="T:System.Data.DataSet"/>.
            Не рекомендуется использовать этот метод, чтобы избежать возникновение SQL Injection при неправильном построении запроса.
            Лучше используйте одну из перегрузок этого метода: <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetData(System.Data.SqlClient.SqlCommand)"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает <see cref="T:System.Data.DataSet"/>, содержащий результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустой <see cref="T:System.Data.DataSet"/>.</para>
            </returns>
            <example>
            <para>
            Следующий пример демонстрирует выполнение двух инструкций <c>SELECT FROM</c>, для получения данных из двух таблиц: <c>messages</c> и <c>users</c>. 
            В случае успешного выполнения запроса, в <see cref="T:System.Data.DataSet"/> в свойстве <see cref="P:System.Data.DataSet.Tables"/> будет две таблицы, содержащие результат выполнения запроса.</para>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // выполняем запрос
              DataSet data = c.GetData("SELECT * FROM messages; SELECT * FROM users;");
              if(data.Tables.Count &gt; 0)
              {
                // есть данные, выводим в консоль
                foreach(DataTable t in data.Tables)
                {
                  foreach(DataRow r in table.Rows)
                  {
                    Console.WriteLine("id = {0}", r["id"]);
                  }
                }
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' выполняем запрос
              Dim data As DataSet = c.GetData("SELECT * FROM messages; SELECT * FROM users;")
              If data.Tables.Count &gt; 0 Then
                ' есть данные, выводим в консоль
                For Each t As DataTable In data.Tables
                  For Each r As DataRow In table.Rows
                    Console.WriteLine("id = {0}", r("id"))
                  Next
                Next
              End If
            End Using
            </code>
            <para>
            Следующий пример демонстрирует динамическое построение SQL-запроса в веб-проекте. В запрос передается значение из параметра <c>search</c> адресной строки.
            Например, адрес страницы может быть следующим: http://example.org/users?search=pupkin.
            </para>
            <para>
            Этот код содержит уязвимость типа SQL Injection. Поскольку любой пользователь имеет доступ к своей адресной строке и может указать туда все, что угодно, 
            в том числе любую SQL-инструкцию. Например, чтобы удалить все данные из таблицы, достаточно указать следующий адрес страницы:
            http://example.org/users?search='; DELETE FROM users; --
            </para>
            <para>Именно поэтому не рекомендуется использовать подобные методы построения SQL-запросов, лучше используйте методы <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetData(System.Data.SqlClient.SqlCommand)"/>.</para>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // выполняем запрос
              DataSet data = c.GetData("SELECT * FROM users WHERE first_name LIKE '%" + Request["search"] + "%'");
              if(data.Tables.Count &gt; 0)
              {
                // есть данные, выводим в консоль
                foreach(DataTable t in data.Tables)
                {
                  foreach(DataRow r in table.Rows)
                  {
                    Console.WriteLine("id = {0}", r["id"]);
                  }
                }
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' выполняем запрос
              Dim data As DataSet = c.GetData("SELECT * FROM users WHERE first_name LIKE '%" &amp; Request("search") &amp; "%'")
              If data.Tables.Count &gt; 0 Then
                ' есть данные, выводим в консоль
                For Each t As DataTable In data.Tables
                  For Each r As DataRow In table.Rows
                    Console.WriteLine("id = {0}", r("id"))
                  Next
                Next
              End If
            End Using
            </code>
            <para>
            Избежать инъекции, в данном примере, можно сделав проверку на наличие в параметре символа одинарной кавычки или экранировать кавычки: <c>Request["search"].Replace("'", "''")</c>. 
            Но это не все проблемы, с которыми можно столкнуться при подобном способе построения запросов.
            Именно поэтому не рекомендуется использовать подобные методы построения SQL-запросов, лучше используйте методы <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetData(System.Data.SqlClient.SqlCommand)"/>. ;-)
            </para>
            </example>
            <param name="sql">Запрос SQL, который необходимо выполнить. Будьте очень осторожны при динамическом формировании запроса, особенно при передаче в запрос строковых типов данных.</param>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetData(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос к базе данных с указанными в экземпляре класса <see cref="T:System.Data.SqlClient.SqlCommand"/> параметрами и возвращает <see cref="T:System.Data.DataSet"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает <see cref="T:System.Data.DataSet"/>, содержащий результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустой <see cref="T:System.Data.DataSet"/>.</para>
            </returns>
            <remarks>
            <para>
            В большинстве случаев, рекомендуется использовать метод <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/> без параметров, совместно со свойствами 
            <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            Суть будет примерно такой же, как и с <see cref="T:System.Data.SqlClient.SqlCommand"/>, но работать удобней.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос
              SqlCommand cmd = new SqlCommand("SELECT * FROM messages; SELECT * FROM users;");
              // выполняем запрос
              DataSet data = c.GetData(cmd);
              if(data.Tables.Count &gt; 0)
              {
                // есть данные, выводим в консоль
                foreach(DataTable t in data.Tables)
                {
                  foreach(DataRow r in table.Rows)
                  {
                    Console.WriteLine("id = {0}", r["id"]);
                  }
                }
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              Dim cmd As New SqlCommand("SELECT * FROM messages; SELECT * FROM users")
              ' выполняем запрос
              Dim data As DataSet = c.GetData(cmd)
              If data.Tables.Count &gt; 0 Then
                ' есть данные, выводим в консоль
                For Each t As DataTable In data.Tables
                  For Each r As DataRow In table.Rows
                    Console.WriteLine("id = {0}", row("id"))
                  Next
                Next
              End If
            End Using
            </code>
            </example>
            <param name="cmd">Экземпляр <see cref="T:System.Data.SqlClient.SqlCommand"/>, содержащий параметры запроса, который необходимо выполнить.</param>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetTable">
            <summary>
            Выполняет запрос и возвращает <see cref="T:System.Data.DataTable"/>.
            Данный метод используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает таблицу, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустую таблицу.</para>
            </returns>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос
              c.CommandText = "SELECT * FROM users;";
              // выполняем запрос
              DataTable table = c.GetTable();
              // выводим результат в консоль
              foreach(DataRow row in table.Rows)
              {
                Console.WriteLine("login = {0}", row["login"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              c.CommandText = "SELECT * FROM users;"
              ' выполняем запрос
              Dim table As DataTable = c.GetTable()
              ' выводим результат в консоль
              For Each row As DataRow In table.Rows
                Console.WriteLine("login = {0}", row("login"))
              Next
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetTable(System.String)">
            <summary>
            Выполняет запрос и возвращает <see cref="T:System.Data.DataTable"/>.
            Не рекомендуется использовать этот метод, чтобы избежать возникновение SQL Injection при неправильном построении запроса.
            Лучше используйте одну из перегрузок этого метода: <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable(System.Data.SqlClient.SqlCommand)"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает таблицу, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустую таблицу.</para>
            </returns>
            <param name="sql">Запрос SQL, который необходимо выполнить. Будьте очень осторожны при динамическом формировании запроса, особенно при передаче в запрос строковых типов данных.</param>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // выполняем запрос
              DataTable table = c.GetTable("SELECT * FROM users;");
              // выводим результат в консоль
              foreach(DataRow row in table.Rows)
              {
                Console.WriteLine("login = {0}", row["login"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' выполняем запрос
              Dim table As DataTable = c.GetTable("SELECT * FROM users;")
              ' выводим результат в консоль
              For Each row As DataRow In table.Rows
                Console.WriteLine("login = {0}", row("login"))
              Next
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetTable(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос к базе данных с указанными в экземпляре класса <see cref="T:System.Data.SqlClient.SqlCommand"/> параметрами и возвращает <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="cmd">Объект типа <see cref="T:System.Data.SqlClient.SqlCommand"/>, который должен содержать текст SQL-запроса, а также параметры запроса.</param>
            <returns>
            <para>Если запрос успешно выполнен, возвращает таблицу, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает пустую таблицу.</para>
            </returns>
            <remarks>
            <para>
            В большинстве случаев, рекомендуется использовать метод <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/> без параметров, совместно со свойствами 
            <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            Суть будет примерно такой же, как и с <see cref="T:System.Data.SqlClient.SqlCommand"/>, но работать удобней.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос
              SqlCommand cmd = new SqlCommand("SELECT * FROM users;");
              // выполняем запрос
              DataTable table = c.GetTable(cmd);
              // выводим результат в консоль
              foreach(DataRow row in table.Rows)
              {
                Console.WriteLine("login = {0}", row["login"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              Dim cmd As New SqlCommand("SELECT * FROM users;")
              ' выполняем запрос
              Dim table As DataTable = c.GetTable(cmd)
              ' выводим результат в консоль
              For Each row As DataRow In table.Rows
                Console.WriteLine("login = {0}", row("login"))
              Next
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetRow">
            <summary>
            Выполняет запрос и возвращает строку данных.
            Данный метод используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает строку, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            </returns>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос
              c.CommandText = "SELECT * FROM users WHERE login = 'anylogin';";
              // выполняем запрос
              DataRow row = c.GetRow();
              // выводим результат в консоль, если есть
              if(row != null)
              {
                Console.WriteLine("nickname = {0}", row["nickname"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              c.CommandText = "SELECT * FROM users WHERE login = 'anylogin';"
              ' выполняем запрос
              Dim row As DataRow = c.GetRow()
              ' выводим результат в консоль, если есть
              If row IsNot Nothing Then
                Console.WriteLine("nickname = {0}", row("nickname"))
              End If
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetRow(System.String)">
            <summary>
            Выполняет указанный SQL-запрос и возвращает строку данных.
            Не рекомендуется использовать этот метод, чтобы избежать возникновение SQL Injection при неправильном построении запроса.
            Лучше используйте одну из перегрузок этого метода: <see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetRow(System.Data.SqlClient.SqlCommand)"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает строку, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            </returns>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // выполняем запрос
              DataRow row = c.GetRow("SELECT * FROM users WHERE login = 'anylogin';");
              // выводим результат в консоль, если есть
              if(row != null)
              {
                Console.WriteLine("nickname = {0}", row["nickname"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' выполняем запрос
              Dim row As DataRow = c.GetRow("SELECT * FROM users WHERE login = 'anylogin';")
              ' выводим результат в консоль, если есть
              If row IsNot Nothing Then
                Console.WriteLine("nickname = {0}", row("nickname"))
              End If
            End Using
            </code>
            </example>
            <param name="sql">Запрос SQL, который необходимо выполнить. Будьте очень осторожны при динамическом формировании запроса, особенно при передаче в запрос строковых типов данных.</param>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetRow(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос к базе данных с указанными в экземпляре класса <see cref="T:System.Data.SqlClient.SqlCommand"/> параметрами и возвращает строку данных.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает строку, содержащую результат выполнения запроса.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            </returns>
            <remarks>
            <para>
            В большинстве случаев, рекомендуется использовать метод <see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/> без параметров, совместно со свойствами 
            <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            Суть будет примерно такой же, как и с <see cref="T:System.Data.SqlClient.SqlCommand"/>, но работать удобней.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // формируем запрос 
              SqlCommand cmd = new SqlCommand("SELECT * FROM users WHERE login = 'anylogin';");
              // выполняем запрос
              DataRow row = c.GetRow(cmd);
              // выводим результат в консоль, если есть
              if(row != null)
              {
                Console.WriteLine("nickname = {0}", row["nickname"]);
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' формируем запрос
              Dim cmd As New SqlCommand("SELECT * FROM users WHERE login = 'anylogin';")
              ' выполняем запрос
              Dim row As DataRow = c.GetRow(cmd)
              ' выводим результат в консоль, если есть
              If row IsNot Nothing Then
                Console.WriteLine("nickname = {0}", row("nickname"))
              End If
            End Using
            </code>
            </example>
            <param name="cmd">Объект типа <see cref="T:System.Data.SqlClient.SqlCommand"/>, который должен содержать текст SQL-запроса, а также параметры запроса.</param>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery">
            <summary>
            Выполняет запрос и возвращает количество задействованных в инструкции строк данных.
            Данный метод используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            </summary>
            <returns>
            <para>Возвращает число, содержащее количество задействованных строк данных в результате выполнения запроса.</para>
            <para>Если запрос не коснулся ни одной строки данных, возвращает ноль.</para>
            </returns>
            <remarks>
            <para>Параметры кэширования при работе с этим методом игнорируются.</para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // формируем запрос
              client.CommandText = "UPDATE messages SET hits = hits + 1 WHERE id = 42";
              // выполняем запрос
              int used = client.ExecuteNonQuery();
              // выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' формируем запрос
              client.CommandText = "UPDATE messages SET hits = hits + 1 WHERE id = 42"
              ' выполняем запрос
              Dim used As Integer = client.ExecuteNonQuery()
              ' выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used)
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery(System.String)">
            <summary>
            Выполняет указанный SQL-запрос и возвращает количество задействованных в инструкции строк.
            Не рекомендуется использовать этот метод, чтобы избежать возникновение SQL Injection при неправильном построении запроса.
            Лучше используйте одну из перегрузок этого метода: <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery(System.Data.SqlClient.SqlCommand)"/>.
            </summary>
            <param name="sql">Запрос SQL, который необходимо выполнить. Будьте очень осторожны при динамическом формировании запроса, особенно при передаче в запрос строковых типов данных.</param>
            <returns>
            <para>Возвращает число, содержащее количество задействованных строк данных в результате выполнения запроса.</para>
            <para>Если запрос не коснулся ни одной строки данных, возвращает ноль.</para>
            </returns>
            <remarks>
            <para>Параметры кэширования при работе с этим методом игнорируются.</para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // выполняем запрос
              int used = client.ExecuteNonQuery("UPDATE messages SET hits = hits + 1 WHERE id = 42");
              // выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' выполняем запрос
              Dim used As Integer = client.ExecuteNonQuery("UPDATE messages SET hits = hits + 1 WHERE id = 42")
              ' выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used)
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос к базе данных с указанными в экземпляре класса <see cref="T:System.Data.SqlClient.SqlCommand"/> параметрами и возвращает количество задействованных в инструкции строк.
            </summary>
            <returns>
            <para>Возвращает число, содержащее количество задействованных строк данных в результате выполнения запроса.</para>
            <para>Если запрос не коснулся ни одной строки данных, возвращает ноль.</para>
            </returns>
            <remarks>
            <para>
            В большинстве случаев, рекомендуется использовать метод <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/> без параметров, совместно со свойствами 
            <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            Суть будет примерно такой же, как и с <see cref="T:System.Data.SqlClient.SqlCommand"/>, но работать удобней.
            </para>
            <para>Параметры кэширования при работе с этим методом игнорируются.</para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // формируем запрос
              SqlCommand cmd = new SqlCommand("UPDATE messages SET hits = hits + 1 WHERE id = @id");
              cmd.Parameters.Add("@id", SqlDbType.Int).Value = 42;
              // выполняем запрос
              int used = client.ExecuteNonQuery(cmd);
              // выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' формируем запрос
              Dim cmd As New SqlCommand("UPDATE messages SET hits = hits + 1 WHERE id = @id")
              cmd.Parameters.Add("@id", SqlDbType.Int).Value = 42
              ' выполняем запрос
              Dim used As Integer = client.ExecuteNonQuery(cmd)
              ' выводим результат в консоль
              Console.WriteLine("Обновлено {0} строк", used)
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar">
            <summary>
            Выполняет запрос и возвращает первый столбец первой строки из полученного набора данных.
            Данный метод используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает первый столбец первой строки из полученного набора данных.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            <para>Может вернуть <see cref="F:System.DBNull.Value"/>, если запрос был успешно выполнен и полученное поле имеет значение <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            Результат выполнения запроса может кэшироваться, если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/> 
            больше нуля и <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет отличное от <see cref="F:Nemiro.Data.CachingType.None"/> значение.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // формируем запрос
              client.CommandText = "SELECT nickname FROM users WHERE id_users = @id_users";
              client.Parameters.Add("@id_users", SqlDbType.Int).Value = 1024;
              // выполняем запрос и выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", client.ExecuteScalar());
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' формируем запрос
              client.CommandText = "SELECT nickname FROM users WHERE id_users = @id_users"
              client.Parameters.Add("@id_users", SqlDbType.Int).Value = 1024
              ' выполняем запрос и выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", client.ExecuteScalar())
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar(System.String)">
            <summary>
            Выполняет указанный SQL-запрос и возвращает первый столбец первой строки из полученного набора данных.
            Не рекомендуется использовать этот метод, чтобы избежать возникновение SQL Injection при неправильном построении запроса.
            Лучше используйте одну из перегрузок этого метода: <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar(System.Data.SqlClient.SqlCommand)"/>.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает первый столбец первой строки из полученного набора данных.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            <para>Может вернуть <see cref="F:System.DBNull.Value"/>, если запрос был успешно выполнен и полученное поле имеет значение <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            Результат выполнения запроса может кэшироваться, если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/> 
            больше нуля и <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет отличное от <see cref="F:Nemiro.Data.CachingType.None"/> значение.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // выполняем запрос 
              object result = client.ExecuteScalar("SELECT nickname FROM users WHERE id_users = 1");
              // выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", result);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' выполняем запрос
              Dim result As Object 
              result = client.ExecuteScalar("SELECT nickname FROM users WHERE id_users = 1")
              ' выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", result)
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос к базе данных с указанными в экземпляре класса <see cref="T:System.Data.SqlClient.SqlCommand"/> параметрами и возвращает первый столбец первой строки из полученного набора данных.
            </summary>
            <returns>
            <para>Если запрос успешно выполнен, возвращает первый столбец первой строки из полученного набора данных.</para>
            <para>Если запрос не дал результатов, возвращает <c>NULL</c> (в Visual Basic .NET - <c>Nothing</c>).</para>
            <para>Может вернуть <see cref="F:System.DBNull.Value"/>, если запрос был успешно выполнен и полученное поле имеет значение <c>NULL</c>.</para>
            </returns>
            <remarks>
            <para>
            В большинстве случаев, рекомендуется использовать метод <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/> без параметров, совместно со свойствами 
            <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>.
            Суть будет примерно такой же, как и с <see cref="T:System.Data.SqlClient.SqlCommand"/>, но работать удобней.
            </para>
            <para>
            Результат выполнения запроса может кэшироваться, если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/> 
            больше нуля и <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет отличное от <see cref="F:Nemiro.Data.CachingType.None"/> значение.
            </para>
            </remarks>
            <example>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // формируем запрос
              SqlCommand cmd = new SqlCommand("SELECT nickname FROM users WHERE id_users = @id_users");
              cmd.Parameters.Add("@id_users", SqlDbType.Int).Value = 1024;
              // выполняем запрос и выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", client.ExecuteScalar(cmd));
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' формируем запрос
              Dim cmd As New SqlCommand("SELECT nickname FROM users WHERE id_users = @id_users")
              cmd.Parameters.Add("@id_users", SqlDbType.Int).Value = 1024
              ' выполняем запрос и выводим результат в консоль
              Console.WriteLine("Псевдоним пользователя: {0}", client.ExecuteScalar(cmd))
            End Using
            </code>
            </example>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.ValueForIdentityException">Исключение происходит, если у ключевого свойства отсутствует флаг Identity и при этом соответствующее поле таблицы является числовым счетчиком.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.CopyTableToServer(System.Data.DataTable)">
            <summary>
            Переносит указанную таблицу в базу данных.
            Используется <see cref="T:System.Data.SqlClient.SqlBulkCopy"/>.
            Это самый быстрый и экономичный способ переноса больших объемов данных в базу.
            </summary>
            <remarks>
            <para>Имя таблицы назначения должно быть в свойстве <see cref="P:System.Data.DataTable.TableName"/> экземпляра <see cref="T:System.Data.DataTable"/>.</para>
            <para>Список полей экземпляра <see cref="T:System.Data.DataTable"/> должен совпадать с колонками таблицы базы данных, куда переносятся данные.</para>
            <para>Если коллекция строк в параметре <paramref name="value"/> пустая, то запрос к базе данных не выполняется.</para>
            <para>Используйте этот метод, если необходимо перенести большие объемы данных в базу. Метод работает быстрее и потребляет меньше ресурсов, чем использование SQL-инструкции <c>INSERT INTO</c>.</para>
            <para>Параметры кэширования при работе с этим методом игнорируются.</para>
            </remarks>
            <example>
            <para>В следующем примере в базу данных в таблицу <c>hotels</c> переносится список отелей.</para>
            <para>Для примера, данные формируются случайным образом.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // Создаем экземпляр класса DataTable.
              // В качестве имени таблицы указываем hotels.
              // В базе данных SQL Server должна быть таблица с именем hotels.
              DataTable table = new DataTable("hotels");
              // Добавляем поля в таблицу.
              // Все перечисленные поля должны присутствовать в таблице hotels
              // базы данных SQL Server.
              // Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              // значения для которых сервером формируются автоматически, указывать их не нужно.
              // Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              table.Columns.Add("hotel_code");
              table.Columns.Add("hotel_name");
              table.Columns.Add("hotel_stars");
              table.Columns.Add("date_created");
              // Генератор случайных чисел, для формирования случайных уровней звездности отелей.
              Random rnd = new Random(DateTime.Now.Millisecond);
              // Добавляем в таблицу данные, которые нужно перенести в базу SQL Server.
              for (int i = 0; i &lt;= 1000; i++)
              {
                // В данном примере данные будут случайными.
                table.Rows.Add(Guid.NewGuid().ToString().Substring(0, 4), Guid.NewGuid().ToString().Replace("-", ""), rnd.Next(1, 5), DateTime.Now);
              }
              // Переносим данные в таблицу hotels базы данных SQL Server
              client.CopyTableToServer(table);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' Создаем экземпляр класса DataTable.
              ' В качестве имени таблицы указываем hotels.
              ' В базе данных SQL Server должна быть таблица с именем hotels.
              Dim table As New DataTable("hotels")
              ' Добавляем поля в таблицу.
              ' Все перечисленные поля должны присутствовать в таблице hotels
              ' базы данных SQL Server.
              ' Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              ' значения для которых сервером формируются автоматически, указывать их не нужно.
              ' Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              table.Columns.Add("hotel_code")
              table.Columns.Add("hotel_name")
              table.Columns.Add("hotel_stars")
              table.Columns.Add("date_created")
              ' Генератор случайных чисел, для формирования случайных уровней звездности отелей.
              Dim rnd As New Random(DateTime.Now.Millisecond)
              ' Добавляем в таблицу данные, которые нужно перенести в базу SQL Server.
              For i As Integer = 0 To 1000
                ' В данном примере данные будут случайными.
                table.Rows.Add(Guid.NewGuid().ToString().Substring(0, 4), Guid.NewGuid().ToString().Replace("-", ""), rnd.Next(1, 5), DateTime.Now)
              Next
              ' Переносим данные в таблицу hotels базы данных SQL Server
              client.CopyTableToServer(table)
            End Using
            </code>
            </example>
            <param name="value">Таблица, данные которой нужно перенести в базу SQL Server.</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="value"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.CopyDataToServer(System.Data.DataSet)"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.CopyDataToServer(System.Data.DataSet)">
            <summary>
            Переносит данные из таблиц <see cref="T:System.Data.DataSet"/> в базу данных.
            Используется <see cref="T:System.Data.SqlClient.SqlBulkCopy"/>.
            Это самый быстрый и экономичный способ переноса больших объемов данных в базу.
            </summary>
            <remarks>
            <para>Каждый экземпляр коллекции <see cref="P:System.Data.DataSet.Tables"/> должен содержать имя таблицы назначения в свойстве <see cref="P:System.Data.DataTable.TableName"/>.</para>
            <para>Список полей таблиц должен совпадать с колонками таблиц базы данных, в которые переносятся данные.</para>
            <para>Если коллекция таблиц в параметре <paramref name="value"/> пустая, то запрос к базе данных не выполняется.</para>
            <para>Если определенная таблица не имеет в коллекции строк данных, то запрос к базе данных для этой таблицы выполняться не будет.</para>
            <para>Данные из таблиц переносятся в базу поочередно.</para>
            <para>Если в процессе переноса данных в базу возникнет ошибка, то уже перенесенные данные останутся в базе данных.</para>
            <para>Используйте этот метод, если необходимо перенести большие объемы данных в базу. Метод работает быстрее и потребляет меньше ресурсов, чем использование SQL-инструкции <c>INSERT INTO</c>.</para>
            <para>Параметры кэширования при работе с этим методом игнорируются.</para>
            </remarks>
            <example>
            <para>В следующем примере в базу данных в таблицы <c>hotels</c> и <c>hotels_images</c> переносятся данные отелей.</para>
            <para>Для примера, данные формируются случайным образом.</para>
            <para>Для связи фотографий отелей с отелями используются ключи типа <see cref="T:System.Guid"/>, которые создаются программно (чтобы можно было сделать связь данных).</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // Создаем экземпляр класса DataTable для отелей.
              // В качестве имени таблицы указываем hotels.
              // В базе данных SQL Server должна быть таблица с именем hotels.
              DataTable hotels = new DataTable("hotels");
              // Добавляем поля в таблицу.
              // Все перечисленные поля должны присутствовать в таблице hotels
              // базы данных SQL Server.
              // Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              // значения для которых сервером формируются автоматически, указывать их не нужно.
              // Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              hotels.Columns.Add("id_hotels", typeof(Guid));
              hotels.Columns.Add("hotel_code", typeof(string));
              hotels.Columns.Add("hotel_name", typeof(string));
              hotels.Columns.Add("hotel_stars", typeof(int));
              hotels.Columns.Add("date_created", typeof(DateTime));
              
              // Создаем экземпляр класса DataTable для фотографий отелей.
              // В качестве имени таблицы указываем hotels_images.
              // В базе данных SQL Server должна быть таблица с именем hotels_images.
              DataTable hotelsImages = new DataTable("hotels_images");
              // Добавляем поля в таблицу.
              // Все перечисленные поля должны присутствовать в таблице hotels
              // базы данных SQL Server.
              // Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              // значения для которых сервером формируются автоматически, указывать их не нужно.
              // Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              hotelsImages.Columns.Add("id_hotels", typeof(Guid)); // поле для связи с hotels
              hotelsImages.Columns.Add("image_url", typeof(string));
              
              // Генератор случайных чисел, для формирования случайных данных (для примера).
              Random rnd = new Random(DateTime.Now.Millisecond);
              
              // Добавляем данные, которые нужно перенести в базу SQL Server.
              for (int i = 0; i &lt;= 1000; i++)
              {
                // В данном примере данные будут случайными.
                // Создаем идентификатор для отеля.
                Guid newHotelId = Guid.NewId();
                // Генерируем данные отеля.
                hotels.Rows.Add(newHotelId, Guid.NewGuid().ToString().Substring(0, 4), Guid.NewGuid().ToString().Replace("-", ""), rnd.Next(1, 5), DateTime.Now);
                // Добавляем фотографии.
                int cnt = rnd.Next(0, 9);
                for (int j = 0; j &lt;= cnt; j++)
                {
                  // Передаем newHotelId в поле id_hotels,
                  // таким образом фотография будет связана с конкретным отелем.
                  hotelsImages.Rows.Add(newHotelId, String.Format("http://example.org/{0}", Guid.NewGuid()));
                }
              }
              // Создаем DataSet.
              DataSet data = new DataSet();
              // Добавляем в DataSet таблицы с данными.
              data.Tables.Add(hotels);
              data.Tables.Add(hotelsImages);
              // Переносим данные в базу данных SQL Server
              client.CopyDataToServer(data);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' Создаем экземпляр класса DataTable для отелей.
              ' В качестве имени таблицы указываем hotels.
              ' В базе данных SQL Server должна быть таблица с именем hotels.
              Dim hotels As New DataTable("hotels")
              ' Добавляем поля в таблицу.
              ' Все перечисленные поля должны присутствовать в таблице hotels
              ' базы данных SQL Server.
              ' Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              ' значения для которых сервером формируются автоматически, указывать их не нужно.
              ' Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              hotels.Columns.Add("id_hotels", GetType(Guid))
              hotels.Columns.Add("hotel_code", GetType(String))
              hotels.Columns.Add("hotel_name", GetType(String))
              hotels.Columns.Add("hotel_stars", GetType(Integer))
              hotels.Columns.Add("date_created", GetType(DateTime))
              
              ' Создаем экземпляр класса DataTable для фотографий отелей.
              ' В качестве имени таблицы указываем hotels_images.
              ' В базе данных SQL Server должна быть таблица с именем hotels_images.
              Dim hotelsImages As New DataTable("hotels_images")
              ' Добавляем поля в таблицу.
              ' Все перечисленные поля должны присутствовать в таблице hotels
              ' базы данных SQL Server.
              ' Если в таблице на сервере SQL Server есть идентификаторы-счетчики, 
              ' значения для которых сервером формируются автоматически, указывать их не нужно.
              ' Для надежности, рекомендуется указывать тип данных полей (вторым параметром).
              hotelsImages.Columns.Add("id_hotels", GetType(Guid)) ' поле для связи с hotels
              hotelsImages.Columns.Add("image_url", GetType(String))
              
              ' Генератор случайных чисел, для формирования случайных данных (для примера).
              Dim rnd As New Random(DateTime.Now.Millisecond)
              
              ' Добавляем данные, которые нужно перенести в базу SQL Server.
              For i As Integer = 0 To 1000
                ' В данном примере данные будут случайными.
                ' Создаем идентификатор для отеля.
                Dim newHotelId As Guid = Guid.NewId()
                ' Генерируем данные отеля.
                hotels.Rows.Add(newHotelId, Guid.NewGuid().ToString().Substring(0, 4), Guid.NewGuid().ToString().Replace("-", ""), rnd.Next(1, 5), DateTime.Now)
                ' Добавляем фотографии.
                Dim cnt As Integer = rnd.Next(0, 9)
                For j As Integer = 0 To cnt
                  ' Передаем newHotelId в поле id_hotels,
                  ' таким образом фотография будет связана с конкретным отелем.
                  hotelsImages.Rows.Add(newHotelId, String.Format("http://example.org/{0}", Guid.NewGuid()))
                Next
              Next
              ' Создаем DataSet.
              Dim data As New DataSet()
              ' Добавляем в DataSet таблицы с данными.
              data.Tables.Add(hotels)
              data.Tables.Add(hotelsImages)
              ' Переносим данные в базу данных SQL Server
              client.CopyDataToServer(data)
            End Using
            </code>
            </example>
            <param name="value">Экземпляр класса <see cref="T:System.Data.DataSet"/>, данные которого нужно перенести в базу SQL Server.</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="value"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.CopyTableToServer(System.Data.DataTable)"/>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
            <exception cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">Исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.ValidateParameters(System.Data.SqlClient.SqlCommand@)">
            <summary>
            Проверяет и, если необходимо, корректирует параметры запроса.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetCacheKey(System.String,System.Data.SqlClient.SqlCommand)">
            <summary>
            Возвращает ключ кэша для запроса.
            </summary>
            <param name="type">Тип данных: table, row и т.п.</param>
            <param name="cmd">Комнда, на основе данных которой будет построен ключ.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetFromCache(System.String)">
            <summary>
            Возвращает данные из кэша, если есть.
            </summary>
            <param name="key">Ключ записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.AddToCache(System.String,System.Object)">
            <summary>
            Добавляет данные в кэш.
            </summary>
            <param name="key">Ключ записи.</param>
            <param name="value">Данные, которые нужно записать.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetCacheObject">
            <summary>
            Возвращает объект для работы с кэшем.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.Connect">
            <summary>
            Открывает соединение с базой данных, если нет открытого соединения.
            </summary>
            <remarks>
            <para>Нет необходимости вызывать этот метод отдельно, поскольку соединение с базой данных и так будет открываться при первой необходимости.</para>
            </remarks>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.Disconnect"/>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.Disconnect">
            <summary>
            Закрывает соединение с базой данных, если оно открыто.
            </summary>
            <remarks>
            <para>
            Если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/> имеет значение <see cref="F:Nemiro.Data.ConnectionMode.Auto"/> (по умолчанию),
            то соединения с базой данных будут закрываться автоматически и вызывать отдельно метод <see cref="M:Nemiro.Data.Sql.SqlClient.Disconnect"/> нет необходимости.
            </para>
            <para>При удалении экземпляра класса <see cref="T:Nemiro.Data.Sql.SqlClient"/>, все открытые соединения автоматически закрываются, независимо от значения свойства <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/>.</para>
            </remarks>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.Connect"/>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GetData2(System.Data.SqlClient.SqlCommand)">
            <summary>
            Выполняет запрос и возвращает DataSet, без использования кэша.
            </summary>
            <param name="cmd">Команда, которую нужно выполнить.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlClient.GenerateException(System.Exception)">
            <summary>
            Передает исключение в основной поток.
            </summary>
            <param name="ex">Экземпляр исключения.</param>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.ConnectionString">
            <summary>
            Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (<c>*.config</c>).
            Значение по умолчанию: <c>LocalSqlServer</c>.
            </summary>
            <value>Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле <c>*.config</c>).</value>
            <remarks>
            <para>В качестве <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/> можно указывать, как саму строку соединения, так и имя параметра в файле конфигурации.</para>
            <para>По умолчанию используется строка соединения с именем <c>LocalSqlServer</c>.
            В web-приложениях строка соединения с именем <c>LocalSqlServer</c> иметь путь к SQL Server по умолчанию. 
            Для использования параметра <c>LocalSqlServer</c> в веб-приложениях со своей базой данных, которая отличается от базы по умолчанию,
            необходимо удалить <c>LocalSqlServer</c> из файла конфигурации и добавить заново (написать код удаления и добавления):
            </para>
            <code lang="XML">
            &lt;remove name="LocalSqlServer"/&gt;
            &lt;add 
              name="LocalSqlServer" 
              connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
            /&gt;
            </code>
            <para>
            Как правило, изменение строки соединения в процессе разработки приложения при помощи свойства <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/> не требуется.
            Обычно достаточно одной строки соединения. Если же возникает необходимость использовать нестандартную строку (отличную от <c>LocalSqlServer</c>), то её проще указывать при инициализации класса.
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient(@"Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"))
            {
              // ...
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient("Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"))
              ' ...
            End Using
            </code>
            </remarks>
            <example>
            <para>В следующем примере в свойство <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/> передается новая строка соединения с базой данных, которая будет использоваться при выполнении запросов в рамках жизни экземпляра класса <see cref="T:Nemiro.Data.Sql.SqlClient"/>.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // устанавливаем строку соединения с базой данных
              client.ConnectionString = "Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;";
              // формируем запрос к базе данных
              client.CommandText = "SELECT * FROM table";
              // выполняем запрос
              DataTable table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' устанавливаем строку соединения с базой данных
              client.ConnectionString = "Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"
              ' формируем запрос к базе данных
              client.CommandText = "SELECT * FROM table"
              ' выполняем запрос
              DataTable table = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.ConnectionMode">
            <summary>
            Режим соединения с базой данных.
            Значение по умолчанию <see cref="F:Nemiro.Data.ConnectionMode.Auto"/>, если иное не указано в параметре <c>NeData:Sql:ConnectionMode</c> файла конфигурации.
            </summary>
            <value>Значение по умолчанию: <see cref="F:Nemiro.Data.ConnectionMode.Auto"/>, если иное не указано в параметре <c>NeData:Sql:ConnectionMode</c> файла конфигурации.</value>
            <remarks>
            <para>В режиме <see cref="F:Nemiro.Data.ConnectionMode.Auto"/> при каждом выполнении запроса к базе данных соединение автоматически открывается, а после - закрывается. Например:</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // формируем запрос к базе данных
              client.CommandText = "SELECT * FROM table";
              // выполняем запрос
              // при этом открывается соединение с базой данных
              DataTable table = client.GetTable();
              // после выполнения запроса, соединение автоматически закрывается
              // выполняем еще один запрос, соединение опять открывается
              client.CommandText = "UPDATE table SET hits = hits + 1";
              client.ExecuteNonQuery();
              // после выполнения запроса, соединение автоматически закрывается
              // и т.д.
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' формируем запрос к базе данных
              client.CommandText = "SELECT * FROM table"
              ' выполняем запрос
              ' при этом открывается соединение с базой данных
              Dim table As DataTable = client.GetTable()
              ' после выполнения запроса, соединение автоматически закрывается
              ' выполняем еще один запрос, соединение опять открывается
              client.CommandText = "UPDATE table SET hits = hits + 1"
              client.ExecuteNonQuery()
              ' после выполнения запроса, соединение автоматически закрывается
              ' и т.д.
            End Using
            </code>
            <para>В режиме <see cref="F:Nemiro.Data.ConnectionMode.Auto"/> не стоит беспокоиться о том, что соединение с базой данных может остаться открытым.
            В случае, если в процессе выполнения запроса возникает исключение (ошибка), то соединение закрывается, а лишь затем исключение передается приложению.</para>
            <para>
            В большинстве случаев такой подход оправдан. 
            Однако, если в рамках одно цикла жизни экземпляра класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> необходимо выполнить серию запросов к базе данных, то имеет смысл использовать одно соединение.
            Для реализации этого, достаточно переключить <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/> в ручной режим (<see cref="F:Nemiro.Data.ConnectionMode.Manual"/>).
            Но тогда придется самостоятельно закрывать соединения, и писать дополнительный код на случаи возникнования исключений в процессе выполнения запросов к базе данных, 
            чтобы не оставалось открытых соединений, число которых, как известно, ограничено.
            </para>
            <para>Строго говоря, в ручном режиме соединение открывается автоматически, при первой необходимости. Вручную его нужно только закрывать.</para>
            <para>При вызове метода <see cref="M:Nemiro.Data.Sql.SqlClient.Dispose"/> соединение автоматически закрывается, независимо от значения <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/>.</para>
            </remarks>
            <example>
            <para>В следующем примере выполняться серия запросов к базе данных с использованием одного открытого соединения. При этом выполняется перехват исключений и ручное закрытие соединения с базой данных. Использование оператора <c>using</c> в данном случае невозможно.</para>
            <code lang="C#">
            // создаем экземпляр класса SqlClient
            SqlClient client = new SqlClient();
            // переключаемся в ручной режим управления соединением
            client.ConnectionMode = ConnectionMode.Manual;
            try
            {
              // выполняем серию из пяти запросов в безопасном блоке кода
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());");
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());");
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());");
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());");
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());");
            }
            catch (Exception ex)
            {
              // выводим сообщение об ошибке, 
              // если в процессе выполнения запросов возникнет исключение
              Console.WriteLine(ex.Message);
            }
            finally
            {
              // вручную закрываем соединение с базой данных
              client.Disconnect();
            }
            </code>
            <code lang="VB">
            ' создаем экземпляр класса SqlClient
            Dim client As new SqlClient()
            ' переключаемся в ручной режим управления соединением
            client.ConnectionMode = ConnectionMode.Manual
            Try
              ' выполняем серию из пяти запросов в безопасном блоке кода
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());")
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());")
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());")
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());")
              client.ExecuteNonQuery("INSERT INTO table (date) VALUES (GETDATE());")
            Catch ex As Exception 
              ' выводим сообщение об ошибке, 
              ' если в процессе выполнения запросов возникнет исключение
              Console.WriteLine(ex.Message)
            Finally
              ' вручную закрываем соединение с базой данных
              client.Disconnect()
            End Try
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.Connect"/>
            <seealso cref="M:Nemiro.Data.Sql.SqlClient.Disconnect"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout">
            <summary>
            Время ожидания соединения с сервером (в секундах) до возникновения исключения.
            По умолчанию ноль - будет использоваться значение в зависимости от конфигурации сервера.
            </summary>
            <value>По умолчанию ноль - будет использоваться значение в зависимости от конфигурации сервера.</value>
            <remarks>
            Значение свойства <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout"/> будет автоматически добавлено к строке соединения в параметр <c>Connection Timeout</c>.
            Однако, если строка соединения уже содержит параметр <c>Connection Timeout</c>, то свойство <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout"/> игнорируется.
            </remarks>
            <example>
            <para>В следующем примере устанавливается бесконечное время ожидания соединения с сервером.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.ConnectionTimeout = int.MaxValue;
              // ...
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.ConnectionTimeout = Integer.MaxValue
              ' ...
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionMode"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandTimeout"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CommandType">
            <summary>
            Тип команды, указанной в свойстве <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>.
            Значение по умолчанию <see cref="F:Nemiro.Data.TypeCommand.Auto"/>, если иное не указано в параметре <c>NeData:Sql:CommandType</c> файла конфигурации.
            </summary>
            <value>Значение по умолчанию <see cref="F:Nemiro.Data.TypeCommand.Auto"/>, если иное не указано в параметре <c>NeData:Sql:CommandType</c> файла конфигурации.</value>
            <remarks>
            <para>Данное свойство является калькой с одноименного свойства класса <see cref="T:System.Data.SqlClient.SqlCommand"/>. Однако, в текущей реализации, помимо значений <see cref="F:Nemiro.Data.TypeCommand.StoredProcedure"/>, <see cref="F:Nemiro.Data.TypeCommand.TableDirect"/>, <see cref="F:Nemiro.Data.TypeCommand.Text"/>, это свойство может принимать еще одно дополнительное значение - <see cref="F:Nemiro.Data.TypeCommand.Auto"/> (используется по умолчанию).</para>
            <para>
            Свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/> работает совместно с <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>. 
            В свойстве <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> можно указать текст SQL-запроса, либо имя хранимой процедуры.
            Чтобы запрос был правильно интерпретирован, необходимо указывать <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>, по крайней мере в случае с классом <see cref="T:System.Data.SqlClient.SqlCommand"/>.
            </para>
            <para>В классе <see cref="T:Nemiro.Data.Sql.SqlClient"/>, при типе команды <see cref="F:Nemiro.Data.TypeCommand.Auto"/>, система пытается автоматически определить, что указано в <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>: обычный SQL-запрос (<see cref="F:Nemiro.Data.TypeCommand.Text"/>) или хранимая процедура (<see cref="F:Nemiro.Data.TypeCommand.StoredProcedure"/>).</para>
            <para>Эта операция не требует больших затрат времени. Система проверяет значение <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> по следующему примитивному шаблону:</para>
            <code>(SELECT(.+?)FROM)|(DELETE(\s+)FROM)|(UPDATE(.+?)SET)|(INSERT(\s+)INTO)</code>
            <para>Если <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> совпадает с этим шаблоном, то система считает, что это <see cref="F:Nemiro.Data.TypeCommand.Text"/>.</para>
            <para>Если проверка по шаблону даст отрицательный результат, то система проверяет запрос на пробелы (включая переводы строк). Если пробелы есть, то <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> интерпретируется как <see cref="F:Nemiro.Data.TypeCommand.Text"/>.</para>
            <para>В остальных случаях, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> будет восприниматься в качестве <see cref="F:Nemiro.Data.TypeCommand.StoredProcedure"/>.</para>
            </remarks>
            <example>
            <para>
            В следующем примере явно устанавливается тип команды <see cref="F:Nemiro.Data.TypeCommand.StoredProcedure"/>, чтобы запрос выполнялся как хранимая процедура.
            В свойстве <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> указано имя хранимой процедуры <c>MyProcedure</c>.
            Запрос выполняется методом <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/> (без возврата результатов).
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.CommandType = TypeCommand.StoredProcedure;
              client.CommandText = "MyProcedure";
              client.ExecuteNonQuery();
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.CommandType = TypeCommand.StoredProcedure
              client.CommandText = "MyProcedure"
              client.ExecuteNonQuery()
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CommandText">
            <summary>
            Текст SQL-запроса, либо имя хранимой процедуры, которую необходимо выполнить.
            </summary>
            <remarks>
            <para>Данное свойство является калькой с одноименного свойства класса <see cref="T:System.Data.SqlClient.SqlCommand"/>.</para>
            <para>Если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/> имеет значение <see cref="F:Nemiro.Data.TypeCommand.Auto"/>, то тип <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> определяется автоматически.</para>
            <para>Если необходимо передать в запрос какие-либо параметры, используйте для этого свойство <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>. Не рекомендуется подставлять значения параметров напрямую в текст запроса, чтобы избежать возникнования уязвимости типа SQL Injection.</para>
            </remarks>
            <example>
            <para>В следующем примере выполняется SQL-запрос для удаления записей из таблицы <c>table</c>, у которых значение поля <c>id</c> равняется <c>10</c>. 
            Запрос выполняется методом <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.CommandText = "DELETE FROM table WHERE id = 10";
              client.ExecuteNonQuery();
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.CommandText = "DELETE FROM table WHERE id = 10"
              client.ExecuteNonQuery()
            End Using
            </code>
            <para>
            В следующем примере выполняется SQL инструкция для получения списка пользователей из таблицы <c>users</c>. 
            В запрос передаются параметры <c>age</c> и <c>sex</c> через коллекцию <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>, для выборки пользователей определенного типа.</para>
            <para>Запрос выполняется методом <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>. Результат передается в переменную <c>table</c>,
            после чего полученная таблица выводится в консоль.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.CommandText = "SELECT first_name, last_name, age, sex FROM users WHERE age = @age AND sex = @sex";
              client.Parameters.Add("@age", SqlDbType.Int).Value = 30;
              client.Parameters.Add("@sex", SqlDbType.VarChar, 6).Value = "Female";
              var table = client.GetTable();
              foreach(var row in table.Rows)
              {
                Console.WriteLine("Имя: {0} {1}", row["first_name"], row["last_name"]);
                Console.WriteLine("Пол: {0}", row["sex"]);
                Console.WriteLine("Возраст: {0}", row["age"]);
              }
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.CommandText = "SELECT first_name, last_name, age, sex FROM users WHERE age = @age AND sex = @sex"
              client.Parameters.Add("@age", SqlDbType.Int).Value = 30
              client.Parameters.Add("@sex", SqlDbType.VarChar, 6).Value = "Female"
              Dim table As DataTable = client.GetTable()
              For Each row As DataRow In table.Rows
                Console.WriteLine("Имя: {0} {1}", row("first_name"), row("last_name"))
                Console.WriteLine("Пол: {0}", row("sex"))
                Console.WriteLine("Возраст: {0}", row("age"))
              Next
            End Using
            </code>
            <para>
            Следующий пример демонстрирует динамическое построение SQL-запроса в веб-проекте. В запрос передается значение из параметра <c>search</c> адресной строки.
            Например, адрес страницы может быть следующим: http://example.org/users?search=pupkin.
            </para>
            <para>
            Этот код содержит уязвимость типа SQL Injection. Поскольку любой пользователь имеет доступ к своей адресной строке и может указать туда все, что угодно, 
            в том числе любую SQL-инструкцию. Например, чтобы удалить все данные из таблицы, достаточно указать следующий адрес страницы:
            http://example.org/users?search='; DELETE FROM users; --
            </para>
            <para>Именно поэтому не рекомендуется использовать подобные методы построения SQL-запросов, лучше используйте методы <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/> или <see cref="M:Nemiro.Data.Sql.SqlClient.GetData(System.Data.SqlClient.SqlCommand)"/>.</para>
            <code lang="C#">
            using (SqlClient c = new SqlClient())
            {
              // выполняем запрос
              DataSet data = c.GetData("SELECT * FROM users WHERE first_name LIKE '%" + Request["search"] + "%'");
              if(data.Tables.Count &gt; 0)
              {
                // есть данные, выводим в консоль
                foreach(DataTable t in data.Tables)
                {
                  foreach(DataRow r in table.Rows)
                  {
                    Console.WriteLine("id = {0}", r["id"]);
                  }
                }
              }
            }
            </code>
            <code lang="VB">
            Using c As new SqlClient()
              ' выполняем запрос
              Dim data As DataSet = c.GetData("SELECT * FROM users WHERE first_name LIKE '%" &amp; Request("search") &amp; "%'")
              If data.Tables.Count &gt; 0 Then
                ' есть данные, выводим в консоль
                For Each t As DataTable In data.Tables
                  For Each r As DataRow In table.Rows
                    Console.WriteLine("id = {0}", row("id"))
                  Next
                Next
              End If
            End Using
            </code>
            <para>
            Избежать инъекции, в данном примере, можно сделав проверку на наличие в параметре символа одинарной кавычки или экранировать кавычки: <c>Request["search"].Replace("'", "''")</c>. 
            Но это не все проблемы, с которыми можно столкнуться при подобном способе построения запросов.
            Именно поэтому лучше использовать параметризированные запросы, с использованием свойства <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>, чтобы исключить вторжение из вне в содержимое запроса, а также проблем с преобразованием дат и чисел с плавающей точкой.
            </para>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.Parameters">
            <summary>
            Коллекция параметров запроса.
            </summary>
            <remarks>
            <para>Данное свойство является калькой с одноименного свойства класса <see cref="T:System.Data.SqlClient.SqlCommand"/>.</para>
            <para>Если команда содержит произвольную инструкцию SQL, а не имя хранимой процедуры, число параметров в 
            коллекции должно совпадать с числом замещающих параметры символов в тексте команды, в противном случае SQL Server 
            сгенерирует ошибку. При выполнении хранимой процедуре все параметры, объявленные в ней без значений по умолчанию, 
            должны получить значения. Параметры, объявленные со значениями по умолчанию, не являются обязательными. 
            Это позволяет задавать значение, отличное от используемого по умолчанию.</para>
            </remarks>
            <example>
            <para>
            В следующем примере выполняется SQL инструкция для получения списка пользователей из таблицы <c>users</c>. 
            В запрос передаются параметры <c>age</c> и <c>sex</c>, для выборки пользователей определенного типа.</para>
            <para>Запрос выполняется методом <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>. Результат передается в переменную <c>table</c>,
            после чего полученная таблица выводится в консоль.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.CommandText = "SELECT first_name, last_name, age, sex FROM users WHERE age = @age AND sex = @sex";
              client.Parameters.Add("@age", SqlDbType.Int).Value = 30;
              client.Parameters.Add("@sex", SqlDbType.VarChar, 6).Value = "Female";
              var table = client.GetTable();
              foreach(var row in table.Rows)
              {
                Console.WriteLine("Имя: {0} {1}", row["first_name"], row["last_name"]);
                Console.WriteLine("Пол: {0}", row["sex"]);
                Console.WriteLine("Возраст: {0}", row["age"]);
              }
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.CommandText = "SELECT first_name, last_name, age, sex FROM users WHERE age = @age AND sex = @sex"
              client.Parameters.Add("@age", SqlDbType.Int).Value = 30
              client.Parameters.Add("@sex", SqlDbType.VarChar, 6).Value = "Female"
              Dim table As DataTable = client.GetTable()
              For Each row As DataRow In table.Rows
                Console.WriteLine("Имя: {0} {1}", row("first_name"), row("last_name"))
                Console.WriteLine("Пол: {0}", row("sex"))
                Console.WriteLine("Возраст: {0}", row("age"))
              Next
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CommandTimeout">
            <summary>
            Время ожидания выполнения команды (в секундах). По умолчанию используется значение <c>30 секунд</c>.
            </summary>
            <remarks>
            <para>Данное свойство является калькой с одноименного свойства класса <see cref="T:System.Data.SqlClient.SqlCommand"/>.</para>
            <para>Значение ноль - без ограничений.</para>
            </remarks>
            <example>
            <para>
            В следующем примере на выполнение запроса отводится одна секунда. 
            Инструкция <c>WAITFOR DELAY '00:00:05'</c> задержит выполнение запроса на <c>5</c> секунд, что приведет к возникновению исключения <see cref="T:System.Data.SqlClient.SqlException"/>.
            </para>
            <para>
            Запрос выполняется методом <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/>.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              client.CommandText = "WAITFOR DELAY '00:00:05'";
              client.CommandTimeout = 1;
              client.ExecuteNonQuery();
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient())
              client.CommandText = "WAITFOR DELAY '00:00:05'"
              client.CommandTimeout = 1
              client.ExecuteNonQuery()
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.ConnectionTimeout"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandType"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.Cache">
            <summary>
            Предоставляет доступ к параметрам кэширования.
            </summary>
            <remarks>Данное свойство является закрытым, доступ к нему возможен только внутри сборки. В общем, не берите в голову :-)</remarks>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheType">
            <summary>
            Метод кэширования данных. Значение по умолчанию <see cref="F:Nemiro.Data.CachingType.Auto"/>, если иное не указано в параметре <c>NeData:Sql:CacheType</c> файла конфигурации.
            </summary>
            <remarks>
            <para>Не рекомендуется использовать значение <see cref="F:Nemiro.Data.CachingType.Auto"/>, поскольку на автоматическое определение типа кэширования может потребоваться на пару наносекунд больше, чем если метод кэширования будет указан явно.</para>
            <para>Как правило, метод кэширования указывается один раз в файле конфигурации, в параметре <c>NeData:Sql:CacheType</c> (для веб-приложений) или в параметре <c>NeDataSqlCacheType</c> (для приложений Windows).</para>
            </remarks>
            <example>
            <para>Ниже показан фрагмент файла <c>web.config</c> веб-сайта, в котором указывается метод кэширования, а также дополнительные параметры кэширования данных.</para>
            <code lang="XML">
            &lt;appSettings&gt;
              &lt;clear /&gt;
              &lt;!--Метод кэширования данных--&gt;
              &lt;add key="NeData:Sql:CacheType" value="File" /&gt;
              &lt;!--Путь к файловому кэшу--&gt;
              &lt;add key="NeData:Sql:CachePath" value="C:\Cache\MyApplication" /&gt;
              &lt;!--Объем вспомогательного кэша (Кб)--&gt;
              &lt;add key="NeData:Sql:CacheBufferSize" value="10240" /&gt;
            &lt;/appSettings&gt;
            </code>
            <para>В следующем примере устанавливается метод кэширования программно.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600; // 60 секунд * 60 минут = 3 600 секунд = 1 час
              client.CacheType = CachingType.File;
              // формирование запроса
              client.CommandText = "SELECT * FROM forum_messages";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600 ' 60 секунд * 60 минут = 3 600 секунд = 1 час
              client.CacheType = CachingType.File
              ' формирование запроса
              client.CommandText = "SELECT * FROM forum_messages"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            <code>
            При первом запуске программы, результат может быть следующим:
            --------------------------------------------------------------
            Получено данных: 100
            Время выполнения запроса: 00:00:03
            Результат получен из кэша: False
            --------------------------------------------------------------
            
            При повторном запуске программы, результат может быть следующим:
            --------------------------------------------------------------
            Получено данных: 100
            Время выполнения запроса: 00:00:00
            Результат получен из кэша: True
            --------------------------------------------------------------
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheCustom">
            <summary>
            Тип пользовательского объекта кэширования. Используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.CacheCustomArgs"/>.
            </summary>
            <remarks>
            <para>Пользовательский класс, реализующий доступ к кэшу, должен быть наследован от <see cref="T:System.Runtime.Caching.ObjectCache"/>.</para>
            <para>Чтобы использовать пользовательский класс для работы с кэшем, свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> должно иметь значение <see cref="F:Nemiro.Data.CachingType.Custom"/>.</para>
            <para>Как правило, метод кэширования указывается один раз в файле конфигурации, в параметре <c>NeData:Sql:CacheType</c> (для веб-приложений) или в параметре <c>NeDataSqlCacheType</c> (для приложений Windows).</para>
            <code lang="XML">
            &lt;appSettings&gt;
              &lt;clear /&gt;
              &lt;!--Метод кэширования данных--&gt;
              &lt;add key="NeData:Sql:Custom" value="Custom" /&gt;
              &lt;!--Список дополнительных параметров (через запятую), которые будут переданы в конструктор пользовательского кэша--&gt;
              &lt;add key="NeData:Sql:CacheCustomArgs" value="1,test,123" /&gt;
            &lt;/appSettings&gt;
            </code>
            <para>Работа реализации пользовательских механизмов кэширования на данный момент не проверена и не гарантируется.</para>
            </remarks>
            <example>
            <para>В следующем примере программно устанавливается пользовательский метод кэширования данных и выполняется запрос к SQL Server методом <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/> с кэшированием результатов на <c>60</c> секунд.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 60 секунд
              client.CacheDuration = 60;
              // устанавливаем пользовательский тип кэширования
              client.CacheType = CachingType.Custom;
              // указываем пользовательский тип кээширования
              client.CacheCustom = typeof(MyCache);
              // формирование запроса
              client.CommandText = "SELECT * FROM messages";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 60 секунд
              client.CacheDuration = 60
              ' устанавливаем пользовательский тип кэширования
              client.CacheType = CachingType.Custom
              ' указываем пользовательский тип кээширования
              client.CacheCustom = GetType(MyCache)
              ' формирование запроса
              client.CommandText = "SELECT * FROM messages"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            }
            </code>
            <para>Ниже показан пример реализации класса пользовательского кэша на C#. Это копия кода класса <see cref="T:Nemiro.Data.Caching.WebCache"/>.</para>
            <code lang="C#">
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using System.Runtime.Caching;
            using System.Web;
            
            public class MyCache : ObjectCache
            {
            
              private System.Web.Caching.Cache _Instance = null;
            
              // Политика кэширования по умолчанию.
              public CacheItemPolicy DefaultPolicy { get; set; }
            
              public WebCache()
              {
                if (HttpContext.Current != null)
                {
                  _Instance = HttpContext.Current.Cache;
                  this.DefaultPolicy = new CacheItemPolicy();
                }
                else
                {
                  throw new Exception("HttpContext is requred.");
                }
              }
            
              public WebCache(HttpContext context)
              {
                _Instance = context.Cache;
                this.DefaultPolicy = new CacheItemPolicy();
              }
            
              // Вставляет запись в кэш, используя указанную пару "ключ-значение" и заданные сведения о методе ее удаления.
              public override object AddOrGetExisting(string key, object value, CacheItemPolicy policy, string regionName = null)
              {
                object result = _Instance[key];
                _Instance.Add(key, value, null, policy.AbsoluteExpiration.DateTime, policy.SlidingExpiration, System.Web.Caching.CacheItemPriority.Default, null);
                return result;
              }
            
              // Добавляет запись в кэш, используя заданный экземпляр CacheItem и сведения о способе удаления записи.
              public override CacheItem AddOrGetExisting(CacheItem value, CacheItemPolicy policy)
              {
                object result = this.AddOrGetExisting(value.Key, value.Value, policy, value.RegionName);
                if (result == null) { return null; }
                return new CacheItem(value.Key, result, value.RegionName);
              }
            
              // Добавляет запись в кэш, используя заданную пару "ключ-значение" и абсолютное значение срока действия.  
              public override object AddOrGetExisting(string key, object value, DateTimeOffset absoluteExpiration, string regionName = null)
              {
                CacheItemPolicy policy = new CacheItemPolicy();
                policy.AbsoluteExpiration = absoluteExpiration;
                return this.AddOrGetExisting(key, value, policy, regionName);
              }
            
              // Определяет, существует ли в кэше запись кэша.
              public override bool Contains(string key, string regionName = null)
              {
                return _Instance[key] != null;
              }
            
              // При переопределении в производном классе создает объект CacheEntryChangeMonitor, который может активировать события в ответ на изменения указанных записей кэша.
              public override CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(IEnumerable&lt;string&gt; keys, string regionName = null)
              {
                throw new NotImplementedException();
              }
            
              // Содержит описание функций, предоставляемых реализацией кэша.
              public override DefaultCacheCapabilities DefaultCacheCapabilities
              {
                get
                {
                  return DefaultCacheCapabilities.AbsoluteExpirations | DefaultCacheCapabilities.SlidingExpirations;
                }
              }
            
              // Получает из кэша указанную запись кэша в виде объекта.
              public override object Get(string key, string regionName = null)
              {
                return _Instance.Get(key);
              }
            
              // Получает из кэша указанную запись кэша в виде экземпляра CacheItem.
              public override CacheItem GetCacheItem(string key, string regionName = null)
              {
                return new CacheItem(key, this.Get(key, regionName), regionName);
              }
            
              // Получает общее число записей в кэше.
              public override long GetCount(string regionName = null)
              {
                return _Instance.Count;
              }
            
              // Создает перечислитель, который может использоваться для перебора записей кэша в коллекции.
              protected override IEnumerator&lt;KeyValuePair&lt;string, object&gt;&gt; GetEnumerator()
              {
                List&lt;KeyValuePair&lt;string, object&gt;&gt; result = new List&lt;KeyValuePair&lt;string, object&gt;&gt;();
                System.Collections.IDictionaryEnumerator em = _Instance.GetEnumerator();
                while (em.MoveNext())
                {
                  result.Add(new KeyValuePair&lt;string, object&gt;(em.Key.ToString(), em.Value));
                }
                return result.GetEnumerator();
              }
            
              // Получает набор записей кэша, соответствующих указанным ключам.
              public override IDictionary&lt;string, object&gt; GetValues(IEnumerable&lt;string&gt; keys, string regionName = null)
              {
                Dictionary&lt;string, object&gt; result = new Dictionary&lt;string, object&gt;();
                foreach (string key in keys)
                {
                  result[key] = this.Get(key, regionName);
                }
                return result;
              }
            
              // Имя экземпляра.
              public override string Name
              {
                get { return "ASP .NET"; }
              }
            
              // Удаляет запись из кэша.
              public override object Remove(string key, string regionName = null)
              {
                return _Instance.Remove(key);
              }
            
              // Вставляет запись в кэш в виде экземпляра CacheItem и задает сведения о способе удаления записи.
              public override void Set(string key, object value, CacheItemPolicy policy, string regionName = null)
              {
                base.Add(key, value, policy, regionName);
              }
            
              // Вставляет запись в кэш в виде экземпляра CacheItem и задает сведения о способе удаления записи.
              public override void Set(CacheItem item, CacheItemPolicy policy)
              {
                base.Add(item, policy);
              }
            
              // Вставляет запись в кэш.
              public override void Set(string key, object value, DateTimeOffset absoluteExpiration, string regionName = null)
              {
                base.Add(key, value, absoluteExpiration, regionName);
              }
            
              public override object this[string key]
              {
                get
                {
                  return this.Get(key, null);
                }
                set
                {
                  this.Set(key, value, this.DefaultPolicy, null);
                }
              }
            
            }
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheCustomArgs"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheCustomArgs">
            <summary>
            Массив дополнительных параметров инициализации пользовательского кэша. Эти параметры будут переданы в конструктор пользовательского кэша.
            Используется совместно со свойствами <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.CacheCustom"/>.
            </summary>
            <remarks>
            <para>Если конструктор пользовательского кэша принимает параметры инициализации, то их можно указать в виде массива.</para>
            <para>Важно соблюдать порядок элементов в массиве. Элементы массива будут переданы в параметры последовательно. Количество элементов массива должно соответствовать количеству параметров конструктора.</para>
            <para>Список передваемых аргументов можно указать в файле конфигурации (через запятую) в параметре <c>NeData:Sql:CacheCustomArgs</c> (для веб-приложений) или в параметре <c>NeDataSqlCacheCustomArgs</c> (для приложений Windows).</para>
            <code lang="XML">
            &lt;appSettings&gt;
              &lt;clear /&gt;
              &lt;!--Метод кэширования данных--&gt;
              &lt;add key="NeData:Sql:Custom" value="Custom" /&gt;
              &lt;!--Список дополнительных параметров (через запятую), которые будут переданы в конструктор пользовательского кэша--&gt;
              &lt;add key="NeData:Sql:CacheCustomArgs" value="My cache,C:\test" /&gt;
            &lt;/appSettings&gt;
            </code>
            </remarks>
            <example>
            <para>
            В следующем примере программно устанавливается пользовательский метод кэширования данных и выполняется запрос к SQL Server методом <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/> с кэшированием результатов на <c>60</c> секунд.
            </para>
            <para>
            В пользовательски кэш передаются два строковых параметра: <c>My cache</c> и <c>C:\test</c>.
            Число и тип параметров соответствует количеству принимаемых аргументов в конструкторе класса пользовательского кэша <c>MyCache</c>.
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 60 секунд
              client.CacheDuration = 60;
              // устанавливаем пользовательский тип кэширования
              client.CacheType = CachingType.Custom;
              // указываем пользовательский тип кэширования
              client.CacheCustom = typeof(MyCache);
              // передаем параметры инициализации пользовательского кэша
              client.CacheCustomArgs = new object[] { "My cache", @"C:\test" };
              // формирование запроса
              client.CommandText = "SELECT * FROM messages";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 60 секунд
              client.CacheDuration = 60
              ' устанавливаем пользовательский тип кэширования
              client.CacheType = CachingType.Custom
              ' указываем пользовательский тип кэширования
              client.CacheCustom = GetType(MyCache)
              ' передаем параметры инициализации пользовательского кэша
              client.CacheCustomArgs = New Object() { "My cache", "C:\test" }
              ' формирование запроса
              client.CommandText = "SELECT * FROM messages"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            }
            </code>
            <para>Ниже показан пример реализации конструктора пользовательского кэша класса <c>MyCache</c>, который принимает два строковых параметра.</para>
            <code lang="C#">
            using System.Runtime.Caching;
            
            public class MyCache : ObjectCache
            {
            
              // конструктор пользовательского кэша
              // принимает два строковых параметра: name и path
              public MyCache(string name, string path)
              {
              }
            
              // код реализации пользовательского кэша
              
            }
            </code>
            <code lang="VB">
            Imports System.Runtime.Caching
            
            Public Class MyCache 
              Implements ObjectCache
            
              ' конструктор пользовательского кэша
              ' принимает два строковых параметра: name и path
              Public Sub New(name As String, path As String)
              
              End Sub
            
              ' код реализации пользовательского кэша
              
            End Class
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheCustom"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheName">
            <summary>
            Имя ключа элемента кэша, если нужно указать определенный ключ (по умолчанию, формируется автоматически для конкретного запроса).
            </summary>
            <remarks>
            <para>По умолчанию, имя ключа записи кэша формируется автоматически в виде хеш-суммы на основе <see cref="P:Nemiro.Data.Sql.SqlClient.ConnectionString"/>, <see cref="P:Nemiro.Data.Sql.SqlClient.CommandText"/> и <see cref="P:Nemiro.Data.Sql.SqlClient.Parameters"/> выполняемого запроса.</para>
            <para>При необходимости, вы можете указать любое удобное для вас имя записи кэша. Это может быть полезно для реализации механизмов ручного управления кэшем. Например, если нужно будет удалить определенную запись кэша при внесении изменений в зависимые данные.</para>
            <para>
            Стоит отметить, что в файлом кэше (где имена файлов являются ключами записи кэша) указанное в <see cref="P:Nemiro.Data.Sql.SqlClient.CacheName"/> может быть проигнорировано, если значение 
            содержит недопустимые для файловой системы символы, либо слишком длинное. 
            Однако на работоспособности это не отразится и не вызовет никаких неудобств, просто значение <see cref="P:Nemiro.Data.Sql.SqlClient.CacheName"/> будет преобразовано в хеш-сумму.
            </para>
            <para>ВАЖНО не забывать менять <see cref="P:Nemiro.Data.Sql.SqlClient.CacheName"/>, если с одним экземляром класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> выполняется серия запросов.</para>
            </remarks>
            <example>
            <para>В следующем примере устанавливается индивидуальное имя записи кэша.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600; // 60 секунд * 60 минут = 3 600 секунд = 1 час
              client.CacheType = CachingType.File;
              // имя записи кэша
              client.CacheName = "MyCacheEntry";
              // формирование запроса
              client.CommandText = "SELECT * FROM forum_messages";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600 ' 60 секунд * 60 минут = 3 600 секунд = 1 час
              client.CacheType = CachingType.File
              ' имя записи кэша
              client.CacheName = "MyCacheEntry";
              ' формирование запроса
              client.CommandText = "SELECT * FROM forum_messages"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            <para>После выполнения этого кода, в папке <c>cache</c> должны появиться файлы записи кэша с именами <c>MyCacheEntry.policy</c> и <c>MyCacheEntry.cache</c>.</para>
            <para>Зная имя записи кэша, запись можно, например, удалить из кэша, как показано в примере ниже.</para>
            <code lang="C#">
            Nemiro.Data.Caching.CacheManager.FileCache.Remove("MyCacheEntry");
            </code>
            <code lang="VB">
            Nemiro.Data.Caching.CacheManager.FileCache.Remove("MyCacheEntry")
            </code>
            <para>В этом примере, доступ к файловому кэшу осуществляется через вспомогательный класс <see cref="T:Nemiro.Data.Caching.CacheManager"/>.</para>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheDuration">
            <summary>
            Продолжительность хранения записи в кэше, в секундах.
            Если это свойство имеет значение <c>0</c> или меньше, кэширование данных не выполняется.
            Значение по умолчанию - ноль, если иное не указано в параметре <c>NeData:Sql:CacheDuration</c> файла конфигурации.
            </summary>
            <remarks>
            <para>
            Кэширование выполняется только при использовании методов получения данных, таких как: <see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/>, <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>, <see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/>, <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/> (включая перегрузки).
            </para>
            <para>
            Результаты выполнения запроса к базе данных методом <see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/> (включая перегрузки) не выполняются.
            </para>
            <para>
            Значение для свойства <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/> можно указать в файле конфигурации в параметре 
            <c>NeData:Sql:CacheDuration</c> (для веб-приложений) или в параметре <c>NeDataSqlCacheDuration</c> (для приложений Windows), 
            однако лучше этого не делать, поскольку тогда все запросы к базе данных будут выполняться с указанной продолжительностью кэширования результатов, 
            что может привести к некоторым проблемам в работе вашего приложения (зависит от типа приложения).
            </para>
            <para>
            Если кэш настроен неправильно или недоступен, то кэширование выполняться не будет.
            </para>
            <para>
            <see cref="T:Nemiro.Data.Caching.WebCache"/> может быть использован только в приложениях ASP .NET и не работает в потоках.
            </para>
            <para>
            <see cref="T:System.Runtime.Caching.MemoryCache"/> может неправильно работает в приложениях ASP .NET и предназначен только для использования в приложениях Windows.
            </para>
            </remarks>
            <example>
            <para>
            В следующем примере выполняется запрос к базе данных методом <see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/>. 
            Результат выполнения запроса кэшируется на <c>3 600</c> секунд (<c>1</c> час).
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600; // 60 секунд * 60 минут = 3 600 секунд = 1 час
              // формирование запроса
              client.CommandText = "SELECT * FROM forum_messages";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 1 час
              client.CacheDuration = 3600 ' 60 секунд * 60 минут = 3 600 секунд = 1 час
              ' формирование запроса
              client.CommandText = "SELECT * FROM forum_messages"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CachePath">
            <summary>
            Полный физический путь к каталогу хранения файлов кэша, используется только если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет значение <see cref="F:Nemiro.Data.CachingType.File"/>.
            </summary>
            <remarks>
            <para>Как правило, параметры кэширования указывается один раз в файле конфигурации. Путь к файловому кэшу устанавливается в параметре <c>NeData:Sql:CachePath</c> (для веб-приложений) или в параметре <c>NeDataSqlCachePath</c> (для приложений Windows).</para>
            <code lang="XML">
            &lt;appSettings&gt;
              &lt;clear /&gt;
              &lt;!--Метод кэширования данных--&gt;
              &lt;add key="NeData:Sql:Custom" value="File" /&gt;
              &lt;!--Каталог хранения файлов кэша--&gt;
              &lt;add key="NeData:Sql:CachePath" value="C:\cache\MyApplication" /&gt;
            &lt;/appSettings&gt;
            </code>
            <para>
            Если <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет значение <see cref="F:Nemiro.Data.CachingType.File"/> и свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CachePath"/> не указано, 
            то по умолчанию файлы кэша будут храниться в подкаталоге <c>cache</c> корневого каталога приложения, если конечно путь отсутствует 
            в файле конфигурации в параметре <c>NeData:Sql:CachePath</c> (<c>NeDataSqlCachePath</c>).
            </para>
            <para>Если указанный каталог не существует, он будет создан автоматически.</para>
            <para>При использовании файлового кэша в проектах ASP .NET, убедитесь, что приложение и пользователь IIS имеют доступ на запись и изменение содержимого каталога <see cref="P:Nemiro.Data.Sql.SqlClient.CachePath"/>.</para>
            </remarks>
            <example>
            <para>В следующем примере при работе с данными используется файловый кэш и отдельно указывается путь к хранилищу файлов кэша.</para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 20 минут
              client.CacheDuration = 1200; // 20 минут * 60 секунд = 1 200 секунд
              client.CacheType = CachingType.File;
              // путь к хранилищу файлов кэша
              client.CachePath = @"C:\cache\MyApplication";
              // формирование запроса
              client.CommandText = "SELECT * FROM users";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 20 минут
              client.CacheDuration = 1200 ' 20 минут * 60 секунд = 1 200 секунд
              client.CacheType = CachingType.File
              ' путь к хранилищу файлов кэша
              client.CachePath = "C:\cache\MyApplication"
              ' формирование запроса
              client.CommandText = "SELECT * FROM users"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheBufferSize"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.CacheBufferSize">
            <summary>
            Максимальный объем данных (в килобайтах) для дополнительного кэша в памяти (ОЗУ) компьютера. 
            Кэш памяти используется для ускорения работы файлового кэша (<see cref="F:Nemiro.Data.CachingType.File"/>).
            Значение по умолчанию <c>2048</c> Кб (<c>2</c> Мб).
            </summary>
            <remarks>
            <para>Буфер используется только если свойство <see cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/> имеет значение <see cref="F:Nemiro.Data.CachingType.File"/>.</para>
            <para>Как правило, параметры кэширования указывается один раз в файле конфигурации. Объем памяти вспомогательного кэша устанавливается в параметре <c>NeData:Sql:CacheBufferSize</c> (для веб-приложений) или в параметре <c>NeDataSqlCacheBufferSize</c> (для приложений Windows).</para>
            <code lang="XML">
            &lt;appSettings&gt;
              &lt;clear /&gt;
              &lt;!--Метод кэширования данных--&gt;
              &lt;add key="NeData:Sql:Custom" value="File" /&gt;
              &lt;!--Каталог хранения файлов кэша--&gt;
              &lt;add key="NeData:Sql:CachePath" value="C:\cache\MyApplication" /&gt;
              &lt;!--Объем буфера файлового кэша 50 Мб (50 Мб * (1 Мб = 1024 Кб) = 51 200 Кб)--&gt;
              &lt;add key="NeData:Sql:CacheBufferSize" value="51200" /&gt;
            &lt;/appSettings&gt;
            </code>
            <para>
            Данные помещаются в буфер по мере необходимости и при последующих запросах берутся из памяти, что позволяет не делать лишних операций в файловой системе.
            Если какие-то файлы кэша меняются, то эти изменения автоматически отражаются в буфере.
            </para>
            <para>Не рекомендуется менять объем буфера программно, лучше указать его один раз в файле конфигурации приложения.</para>
            <para>
            Буфер реализован на основе коллекции <see cref="T:System.Collections.Hashtable"/>. Работа буфера является потокобезопасной.
            </para>
            <para>
            При использовании кэша в многопоточных приложениях, буфер, на момент записи в него данных, блокируется. 
            Время блокировки не может превышать трех секунд (зацикливание приложения полностью исключено).
            Блокировка необходима для решения известных проблем с доступом к <see cref="T:System.Collections.Hashtable"/> при очень большом количестве асинхронных запросов (сотни, тысячи запросов в секунду).
            Речь об исключении: InvalidOperationException: Hashtable insert failed. Load factor too high. The most common cause is multiple threads writing to the Hashtable simultaneously.
            Если у вас возникнут проблемы в работе кэша: излишние задержки, или может даже показанное выше исключение, то отключите буфер, установив значение <c>0</c>.
            Но как показывает практика, в обычных условиях проблем в работе буфера не возникает. 
            Механизм блокировки был сделан специально для веб-сайтов, которые ежесекундно посещают сотни уникальных пользователей, 
            которые генерируют тысячи ресурсоемких запросов.
            </para>
            </remarks>
            <example>
            <para>
            В следующем примере показано программное изменение размера буфера файлового кэша. 
            Это может иметь смысл только если требуется выполнить большую серию запросов в рамках срока жизни экземпляра класса <see cref="T:Nemiro.Data.Sql.SqlClient"/>, где необходим кэш.
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // кэширование результатов в файлом кэше на 20 минут
              client.CacheDuration = 1200; // 20 минут * 60 секунд = 1 200 секунд
              client.CacheType = CachingType.File;
              // объем буфера файлового кэша - 100 Мб
              client.CacheBufferSize = 102400;
              // формирование запроса
              client.CommandText = "SELECT * FROM users";
              // выполнение запроса
              var table = client.GetTable();
              // вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count);
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' кэширование результатов в файлом кэше на 20 минут
              client.CacheDuration = 1200 ' 20 минут * 60 секунд = 1 200 секунд
              client.CacheType = CachingType.File
              ' объем буфера файлового кэша - 100 Мб
              client.CacheBufferSize = 102400
              ' формирование запроса
              client.CommandText = "SELECT * FROM users"
              ' выполнение запроса
              Dim table As DataTable = client.GetTable()
              ' вывод результатов
              Console.WriteLine("Получено данных: {0}", table.Rows.Count)
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime)
              Console.WriteLine("Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CachePath"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.LastQueryTime">
            <summary>
            Время, затраченное на выполнение последнего запроса к базе данных.
            </summary>
            <value>Значение по умолчанию <see cref="F:System.TimeSpan.Zero"/>.</value>
            <remarks>
            <para>
            Данное свойство будет содержать время затраченное на выполнение запроса к базе данных нижеперечисленными методами (включая перегрузки):
            <list type="bullet">
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.CopyDataToServer(System.Data.DataSet)"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.CopyTableToServer(System.Data.DataTable)"/></description></item>
            </list>
            </para>
            </remarks>
            <example>
            <para>
            В следующем примере показано выполнение запроса к базе данных и вывод в консоль информации о продолжительности этой операции.
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // запрос WAITFOR DELAY '00:00:03' сделает задержку в 3 секунды
              client.CommandText = "WAITFOR DELAY '00:00:03'";
              // выполнение запроса
              client.ExecuteNonQuery();
              // вывод результатов
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' запрос WAITFOR DELAY '00:00:03' сделает задержку в 3 секунды
              client.CommandText = "WAITFOR DELAY '00:00:03'"
              ' выполнение запроса
              client.ExecuteNonQuery();
              ' вывод результатов
              Console.WriteLine("Время выполнения запроса: {0}", client.LastQueryTime);
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.LastQueryResultsFromCache"/>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlClient.LastQueryResultsFromCache">
            <summary>
            Содержит <c>True</c>, если при выполнении последнего запроса результат был получен из кэша. 
            В противном случае - <c>False</c>.
            </summary>
            <remarks>
            <para>
            Данное свойство будет изменяться при любом запросе к базе данных нижеперечисленными методами (включая перегрузки):
            <list type="bullet">
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetData"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetTable"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.GetRow"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteScalar"/></description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.ExecuteNonQuery"/> (кэш не используется)</description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.CopyDataToServer(System.Data.DataSet)"/> (кэш не используется)</description></item>
            <item><description><see cref="M:Nemiro.Data.Sql.SqlClient.CopyTableToServer(System.Data.DataTable)"/> (кэш не используется)</description></item>
            </list>
            </para>
            <para>Свойство <see cref="P:Nemiro.Data.Sql.SqlClient.LastQueryResultsFromCache"/> будет иметь значение отличное от <c>False</c>, если <see cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/> больше нуля и запрос выполняется не первый раз.</para>
            </remarks>
            <example>
            <para>
            В следующем примере показано выполнение запроса к базе данных и вывод в консоль значения свойства <see cref="P:Nemiro.Data.Sql.SqlClient.LastQueryResultsFromCache"/>.
            </para>
            <code lang="C#">
            using (SqlClient client = new SqlClient())
            {
              // включаем кэширование
              client.CacheDuration = 1200;
              // формируем запрос
              client.CommandText = "SELECT TOP 100 * FROM proxy";
              // выполненяем запрос
              var table = client.GetTable();
              // выводим результат
              Console.WriteLine("1. Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
              // выполненяем аналогичный запрос повторно
              var table = client.GetTable();
              Console.WriteLine("2. Результат получен из кэша: {0}", client.LastQueryResultsFromCache);
            }
            </code>
            <code lang="VB">
            Using client As New SqlClient()
              ' включаем кэширование
              client.CacheDuration = 1200
              ' формируем запрос 
              client.CommandText = "SELECT TOP 100 * FROM proxy"
              ' выполненяем запрос
              Dim table As DataTable = client.GetTable()
              ' выводим результат
              Console.WriteLine("1. Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
              ' выполненяем аналогичный запрос повторно
              table = client.GetTable()
              Console.WriteLine("2. Результат получен из кэша: {0}", client.LastQueryResultsFromCache)
            End Using
            </code>
            </example>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.LastQueryTime"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheDuration"/>
            <seealso cref="P:Nemiro.Data.Sql.SqlClient.CacheType"/>
        </member>
        <member name="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">
            <summary>
            Исключение возникает, если в классе не найдено ни одного свойства с флагами <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.
            </summary>
            <remarks>
            <para>Это исключение может возникнуть при попытке доступа к методам работы с данными в классах ORM.</para>
            <para>Для исправления ошибки, необходимо, чтобы в классе было хотя бы одно свойство с атрибутом <see cref="T:Nemiro.Data.ColumnAttribute"/>
            и флагом <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> либо <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.SerializableDataColumnCollection">
            <summary>
            Реализует коллекцию сериализуемых <see cref="T:System.Data.DataColumn"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataColumnCollection.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataColumnCollection"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataColumnCollection.#ctor(System.Data.DataColumnCollection)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataColumnCollection"/>.
            </summary>
            <param name="columns">Коллекция колонок, на основе которой будет создана коллекция <see cref="T:Nemiro.Data.Caching.SerializableDataColumnCollection"/>.</param>
        </member>
        <member name="M:Nemiro.Data.Helper.ConvertCommandType(Nemiro.Data.TypeCommand,System.String)">
            <summary>
            Конвертирует локальный тип команды в обычный.
            </summary>
            <param name="cmdType">Локальный тип команды.</param>
            <param name="cmdText">Инструкция SQL, либо имя хранимой процедуры.</param>
        </member>
        <member name="M:Nemiro.Data.Helper.GetSetting(System.String,System.Boolean)">
            <summary>
            Возвращает значений указанной настройки.
            </summary>
            <param name="key">Имя параметра, значение которого нужно получить.</param>
            <param name="connectionString">Приоритет на строку соединения.</param>
        </member>
        <member name="M:Nemiro.Data.Helper.GetConnectionString(System.String,System.Int32)">
            <summary>
            Возвращает строку соединения с базой данных.
            </summary>
            <param name="value">Необходимая строка, может быть именем параметра в конфиге.</param>
            <param name="connectionTimeout">Максимальное время ожидания соединения с базой данных до возникновения исключения.</param>
        </member>
        <member name="M:Nemiro.Data.Helper.GetColumnAttribute(System.Reflection.PropertyInfo)">
            <summary>
            Ищет и возвращает ColumnAttribute указанного свойства.
            </summary>
            <param name="property">Свойство, их которого нужно получить ColumnAttribute.</param>
        </member>
        <member name="M:Nemiro.Data.Helper.SetSqlParametersFromUniqueProperties(System.Object,Nemiro.Data.Sql.SqlClient)">
            <summary>
            Устанавливает клиенту параметры SQL на основе свойств класса с флагом Unique.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Helper.ChangeType(System.Object,System.Type)">
            <summary>
            Возвращает объект указанного типа.
            </summary>
            <param name="value">Объект</param>
            <param name="conversionType">Какой тип нужен</param>
        </member>
        <member name="P:Nemiro.Data.Helper.IsWeb">
            <summary>
            Содерджит <c>true</c>, если текущее приложение является веб-проектом.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheCleanupResult">
            <summary>
            Результат очистки кэша.
            </summary>
            <remarks>
            <para>Используется в файловом кэше (<see cref="T:Nemiro.Data.Caching.FileCache"/>).</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheCleanupResult.Removed">
            <summary>
            Количество успешно удаленных записей.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheCleanupResult.RemovedSize">
            <summary>
            Объем успешно удаленных записей (в байтах).
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheCleanupResult.Errors">
            <summary>
            Число возникших ошибок в процессе удаления.
            </summary>
        </member>
        <member name="T:Nemiro.Data.DataObjectCollection`1">
            <summary>
            Коллекция сущностей базы данных.
            </summary>
            <typeparam name="T">Тип сущности.</typeparam>
        </member>
        <member name="M:Nemiro.Data.DataObjectCollection`1.#ctor(System.Type,System.Int32,System.Int32,System.Int32,System.String[],System.Object,System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.DataObjectCollection`1"/>.
            </summary>
            <param name="T">Тип сущности.</param>
            <param name="recorsPerPage">Максимальное количество записей, которое может находиться на одной странице.</param>
            <param name="currentPage">Текущая страница.</param>
            <param name="totalRecords">Общее количество записей по запросу, без учета страниц.</param>
            <param name="includedFields">Список полей, которые включены в запрос на выборку.</param>
            <param name="sorted">Тип сортировки результатов запроса.</param>
            <param name="filtered">Порядок фильтрации записей.</param>
        </member>
        <member name="M:Nemiro.Data.DataObjectCollection`1.#ctor(Nemiro.Data.DataObjectCollection{Nemiro.Data.Sql.BaseObject})">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.DataObjectCollection`1"/> на основе <see cref="T:Nemiro.Data.Sql.BaseObject"/>.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Nemiro.Data.DataObjectCollection`1.PreviousPage">
            <summary>
            Загружает в коллекцию список записей для предыдущей страницы.
            Записи для текущей страницы удаляются из текущего экземляра <see cref="T:Nemiro.Data.DataObjectCollection`1"/>.
            </summary>
            <returns>
            <para>Если <see cref="P:Nemiro.Data.DataObjectCollection`1.CurrentPage"/> больше 1 (т.е. можно перейти к предыдущей странице), возвращает <c>True</c>. В противном случае - <c>False</c></para>
            </returns>
        </member>
        <member name="M:Nemiro.Data.DataObjectCollection`1.NextPage">
            <summary>
            Загружает в коллекцию список записей для следующей страницы.
            Записи для текущей страницы удаляются из текущего экземляра <see cref="T:Nemiro.Data.DataObjectCollection`1"/>.
            </summary>
            <returns>
            <para>Если <see cref="P:Nemiro.Data.DataObjectCollection`1.CurrentPage"/> меньше <see cref="P:Nemiro.Data.DataObjectCollection`1.TotalPages"/> (т.е. можно перейти к следующей странице), возвращает <c>True</c>. В противном случае - <c>False</c></para>
            </returns>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.CurrentPage">
            <summary>
            Текущая страница.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.TotalRecords">
            <summary>
            Общее количество записей по запросу, без учета страниц.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.RecordsPerPage">
            <summary>
            Максимальное количество записей, которое может находиться на одной странице.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.TotalPages">
            <summary>
            Общее количество страниц.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.IncludedFields">
            <summary>
            Список полей, которые включены в запрос на выборку.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.Sorted">
            <summary>
            Тип сортировки результатов запроса.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataObjectCollection`1.Filtered">
            <summary>
            Порядок фильтрации записей.
            </summary>
        </member>
        <member name="T:Nemiro.Data.ConnectionStringNullException">
            <summary>
            Исключение возникает, если строка соединения с базой данных не указана или имеет пустое значение.
            </summary>
            <remarks>
            <para>Чтобы исправить эту ошибку, необходимо указать строку соединения с именем <c>LocalSqlServer</c> в файле конфигурации приложения.</para>
            <para>Например, в приложениях ASP .NET это можно сделать в файле <c>web.comfig</c> следующим образом.</para>
            <code lang="XML">
            &lt;remove name="LocalSqlServer"/&gt;
            &lt;add 
              name="LocalSqlServer" 
              connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
            /&gt;
            </code>
            <para>Либо указать строку соединения явно. Обычно, в свойство <c>ConnectionString</c> экземпляра объекта, который вы используйте для работы с базой данных.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.ConnectionStringNullException.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ConnectionStringNullException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.FileCache">
            <summary>
            Реализует кэш в файловой системе.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor">
            <summary>
            Инициализирует новый экземпляр файлового кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor(System.String)">
            <summary>
            Инициализирует новый экземпляр файлового кэша с указанием пути к каталогу хранения файлов кэша.
            </summary>
            <param name="cachePath">Путь хранения файлов кэша. </param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor(System.String,System.Int64)">
            <summary>
            Инициализирует новый экземпляр файлового кэша с указанием пути к каталогу хранения файлов кэша и размером буфера.
            </summary>
            <param name="cachePath">Путь хранения файлов кэша.</param>
            <param name="bufferSize">Размер буфера памяти (в килобайтах) для дополнительного кэширования данных в ОЗУ компьютера, для улучшения производительности.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor(System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Инициализирует новый экземпляр файлового кэша с указанием класса сериализации пользовательских типов.
            </summary>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
            <remarks>По умолчанию используется <see cref="T:Nemiro.Data.Caching.CacheBinder"/>.</remarks>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor(System.String,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Инициализирует новый экземпляр файлового кэша с указанием пути к каталогу хранения файлов кэша и класса сериализации пользовательских типов.
            </summary>
            <param name="cachePath">Путь хранения файлов кэша.</param>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.#ctor(System.String,System.Int64,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Инициализирует новый экземпляр файлового кэша.
            </summary>
            <param name="cachePath">Путь хранения файлов кэша.</param>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
            <param name="bufferSize">Размер буфера памяти (в килобайтах) для дополнительного кэширования данных в ОЗУ компьютера, для улучшения производительности.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetKeys(System.String)">
            <summary>
            Возвращает список всех ключей для указанного региона. 
            </summary>
            <param name="regionName">Имя региона. По умолчанию: <c>null</c> (<c>Nothing</c>).</param>
            <returns>Строковой массив, содержащий ключи записей кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetStream(System.String,System.IO.FileMode,System.IO.FileAccess)">
            <summary>
            Возвращает файловый поток.
            </summary>
            <param name="path"></param>
            <param name="mode"></param>
            <param name="access"></param>
            <returns>Возвращает исключение, если файл нельзя открыть.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.ReadFile(System.String,System.String,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Читает файл и возвращает запись кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.WriteFile(System.String,Nemiro.Data.Caching.CacheEntry,System.String)">
            <summary>
            Записывает данные в файл.
            </summary>
            <param name="key">Ключ кэша.</param>
            <param name="entry">Данные, которые нужно записать.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.DeleteCacheFiles(System.String,System.String)">
            <summary>
            Удаляет файлы записи кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.DeleteFile(System.String)">
            <summary>
            Удаляет файл.
            </summary>
            <param name="path">Путь к файлу.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetPolicy(System.String,System.String,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Возрвщает информацию о хранении указанной записи кэша.
            </summary>
            <param name="key">Ключ записи кэша, сведения о которой нужно получить.</param>
            <param name="regionName">Имя региона. По умолчанию: <c>null</c> (<c>Nothing</c>).</param>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.UpdatePolicy(System.String,Nemiro.Data.Caching.CacheEntryPolicy,System.String)">
            <summary>
            Обновляет политики указанной записи кэша.
            </summary>
            <param name="key">Ключ записи кэша.</param>
            <param name="regionName">Именованная область записи кэша. По умолчанию: <c>null</c> (<c>Nothing</c>)</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.UpdatePolicy(System.String,Nemiro.Data.Caching.CacheEntry,System.String)">
            <summary>
            Обновляет политики указанной записи кэша.
            </summary>
            <param name="key">Ключ записи кэша.</param>
            <param name="entry">Данные, которые нужно обновить.</param>
            <param name="regionName">Именованная область записи кэша. По умолчанию: <c>null</c> (<c>Nothing</c>)</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.HasCacheFiles(System.String,System.String)">
            <summary>
            Проверяет целостность файлов кэша. Возвращает true, если все файлы кэша существуют.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCacheDataPath(System.String,System.String)">
            <summary>
            Возвращает путь к файлу кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCachePolicyPath(System.String,System.String)">
            <summary>
            Возвращает путь к файлу сведений о кэше.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCacheDirPath(System.String)">
            <summary>
            Возвращает путь к каталогу кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCacheFileSize(System.String,System.String)">
            <summary>
            Возвращает размер файлов кэша указанного ключа.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            Вставляет запись в кэш, используя указанную пару "ключ-значение" и заданные сведения о методе ее удаления.
            </summary>
            <param name="key">Уникальный идентификатор записи кэшаь.</param>
            <param name="value">Данные записи кэша.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша. Данный объект предоставляет больше параметров для удаления, чем простой абсолютный срок действия.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша. По умолчанию: <c>null</c> (<c>Nothing</c>).</param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Добавляет запись в кэш, используя заданный экземпляр <see cref="T:System.Runtime.Caching.CacheItem"/> и сведения о способе удаления записи.
            </summary>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)">
            <summary>
            Добавляет запись в кэш, используя заданную пару "ключ-значение" и абсолютное значение срока действия.  
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="absoluteExpiration">Фиксированные дата и время истечения срока хранения записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша. </param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Contains(System.String,System.String)">
            <summary>
            Определяет, существует ли в кэше запись с указанным ключом.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <returns>Значение <c>True</c>, если в кэше содержится запись с указанным ключом; в противном случае — значение <c>False</c>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Создает объект <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor"/>, который может активировать события в ответ на изменения указанных записей кэша.
            </summary>
            <param name="keys">Уникальные идентификаторы записей кэша, которые необходимо отслеживать.</param>
            <param name="regionName">Именованная область кэша, в которой могут существовать ключи кэша в параметре <paramref name="keys"/>.</param>
            <returns>Монитор изменений, следящий за записями в кэше.</returns>
            <remarks>В текущей реализации данный метод не поддерживается.</remarks>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Get(System.String,System.String)">
            <summary>
            Получает из кэша указанную запись в виде объекта.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которой может находиться запись кэша.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCacheItem(System.String,System.String)">
            <summary>
            Получает из кэша указанную запись в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/>.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которой может существовать ключ кэша, указанный в параметре <paramref name="key"/>.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetCount(System.String)">
            <summary>
            Получает общее число записей, находящихся в кэше.
            </summary>
            <param name="regionName">Именованная область кэша, для которой необходимо вычислить количество записей.</param>
            <returns>Число записей в кэше. Если значение <paramref name="regionName"/> не равно <c>null</c> (<c>Nothing</c>), 
            это число обозначает количество записей в указанной области кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetEnumerator(System.String)">
            <summary>
            Создает перечислитель, который может использоваться для перебора записей кэша в коллекции.
            </summary>
            <param name="regionName">Именованная область кэша, для которой необходимо вычислить количество записей кэша.</param>
            <returns>Объект перечислителя, предоставляющий доступ к записям кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetEnumerator">
            <summary>
            Создает перечислитель, который может использоваться для перебора записей кэша в коллекции.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Получает набор записей кэша, соответствующих указанным ключам.
            </summary>
            <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которую были добавлены одна или несколько записей кэша.</param>
            <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Remove(System.String,System.String)">
            <summary>
            Удаляет запись из кэша.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую требуется удалить.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <returns>Объект, представляющий значение удаленной записи кэша, заданной данным ключом, или значение <c>null</c> (<c>Nothing</c>), если заданная запись не найдена.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            Вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/> и задает сведения о способе удаления записи.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/> и задает сведения о способе удаления записи.
            </summary>
            <param name="item">Данные, которые нужно поместить в кэш.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)">
            <summary>
            Вставляет запись в кэш.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.CleanupAll">
            <summary>
            Удаляет все записи из кэша.
            </summary>
            <remarks>
            <para>Метод полностью очищает хранилище и удаляет все записи из кэша.</para>
            </remarks>
            <returns>
            Результат удаления в виде объекта <see cref="T:Nemiro.Data.Caching.CacheCleanupResult"/>, 
            содержащего сведения о количестве удаленных данных и возникших ошибках.
            </returns>
            <seealso cref="M:Nemiro.Data.Caching.FileCache.Cleanup"/>
        </member>
        <member name="M:Nemiro.Data.Caching.FileCache.Cleanup">
            <summary>
            Удаляет устаревшие записи из кэша.
            </summary>
            <returns>
            Результат удаления в виде объекта <see cref="T:Nemiro.Data.Caching.CacheCleanupResult"/>, 
            содержащего сведения о количестве удаленных данных и возникших ошибках.
            </returns>
            <seealso cref="M:Nemiro.Data.Caching.FileCache.CleanupAll"/>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.BufferSize">
            <summary>
            Максимальный объем данных (в килобайтах) для дополнительного кэша в памяти (ОЗУ) компьютера. 
            Кэш памяти используется для ускорения работы файлового кэша.
            </summary>
            <value>
            Значение по умолчанию <c>2048</c> Кб (<c>2</c> Мб). Чтобы отключить буфе, установите значение ноль.
            </value>
            <remarks>
            <para>
            Данные помещаются в буфер по мере необходимости и при последующих запросах берутся из памяти, что позволяет не делать лишних операций в файловой системе.
            Если какие-то файлы кэша меняются, то эти изменения автоматически отражаются в буфере.
            </para>
            <para>Не рекомендуется менять объем буфера программно, лучше указать его один раз при инициализации.</para>
            <para>
            Буфер реализован на основе коллекции <see cref="T:System.Collections.Hashtable"/>. Работа буфера является потокобезопасной.
            </para>
            <para>
            При использовании кэша в многопоточных приложениях, буфер, на момент записи в него данных, блокируется. 
            Время блокировки не может превышать трех секунд (зацикливание приложения полностью исключено).
            Блокировка необходима для решения известных проблем с доступом к <see cref="T:System.Collections.Hashtable"/> при очень большом количестве асинхронных запросов (сотни, тысячи запросов в секунду).
            Речь об исключении: InvalidOperationException: Hashtable insert failed. Load factor too high. The most common cause is multiple threads writing to the Hashtable simultaneously.
            Если у вас возникнут проблемы в работе кэша: излишние задержки, или может даже показанное выше исключение, то отключите буфер, установив значение <c>0</c>.
            Но как показывает практика, в обычных условиях проблем в работе буфера не возникает. 
            Механизм блокировки был сделан специально для веб-сайтов, которые ежесекундно посещают сотни уникальных пользователей, 
            которые генерируют тысячи ресурсоемких запросов.
            </para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.CachePath">
            <summary>
            Полный физический путь к каталогу хранения файлов кэша.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.DefaultCachePath">
            <summary>
            Полный физический путь к каталогу хранения файлов кэша, используемый по умолчанию.
            </summary>
            <remarks>
            <para>По умолчанию файлы кэша размещаются в подкаталоге <c>Cache</c> корневого каталога приложения.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.DefaultRegion">
            <summary>
            Именованная область кэша по умолчанию.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.DefaultPolicy">
            <summary>
            Политика кэширования по умолчанию.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.AccessTimeout">
            <summary>
            Максимальное время ожидания освобождения доступа к файлу кэша. По истечению указанного времени, если файл не станет доступен, произойдет исключение.
            </summary>
            <value>Значение по умолчанию <c>00:00:00</c>.</value>
            <example>
            <code lang="C#">
            var fileCache = new Nemiro.Data.Caching.FileCache();
            fileCache.AccessTimeout = new TimeSpan(0, 0, 3); // время ожидания 3 секнуды
            </code>
            <code lang="VB">
            Dim fileCache As New Nemiro.Data.Caching.FileCache()
            fileCache.AccessTimeout = New TimeSpan(0, 0, 3) ' время ожидания 3 секнуды
            </code>
            </example>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.Item(System.String)">
            <summary>
            Возвращает запись кэша с указанным ключом. Если записи нет, возвращает <c>null</c> (<c>Nothing</c>).
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.DefaultCacheCapabilities">
            <summary>
            Содержит описание функций, предоставляемых реализацией кэша.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.FileCache.Name">
            <summary>
            Имя экземпляра.
            </summary>
        </member>
        <member name="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException">
            <summary>
            Данное исключение возникает, если в некоторые поля таблицы добавляются значения, объем которых превышает допустимый размер поля таблицы.
            </summary>
            <remarks>
            <para>Например, в таблице есть поле <c>field as nvarchar(5)</c>, если добавлять в него строку <c>привет</c>, 
            то возникнет исключение, т.к. размер строки <c>привет</c> больше <c>5</c> символов.</para>
            <para>Чтобы исправить эту ошибку, увеличьте размер поля, либо укажите параметр <c>Size</c> для автоматического усечения данных.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException.#ctor(System.Exception)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.StringOrBinaryDataWouldBeTruncatedException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheEntry">
            <summary>
            Представляет сериализуемую запись кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry.#ctor(System.Object)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.CacheEntry"/>.
            </summary>
            <param name="data">Данные записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry.#ctor(System.Object,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.CacheEntry"/>.
            </summary>
            <param name="data">Данные записи кэша.</param>
            <param name="policy">Сведения о хранении записи.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Сериализует значение в поток.
            </summary>
            <param name="stream">Поток, в который будет выполнена сериализация.</param>
            <param name="value">Данные, которые нужно сериализовать.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry.Deserialize(System.IO.Stream,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Десериализует значение из потока.
            </summary>
            <param name="stream">Поток данных, из которого нужно десериализоваться.</param>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry._Serialize(System.IO.Stream)">
            <summary>
            Сериализует себя целиком в поток.
            </summary>
            <param name="stream">Поток, в который будет выполнена сериализация.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntry._Deserialize(System.IO.Stream,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Десериализует себя целиком из одного потока.
            </summary>
            <param name="stream">Поток данных, из которого нужно десериализоваться.</param>
            <param name="binder">Класс сериализации пользовательских объектов.</param>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheEntry.Value">
            <summary>
            Данные записи кэша.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheEntry.Policy">
            <summary>
            Сведения о хранении записи.
            </summary>
        </member>
        <member name="T:Nemiro.Data.DuplicateTableNameException">
            <summary>
            Исключение возникает, если в базе данных уже есть таблица с указанным именем.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DuplicateTableNameException.#ctor(System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.DuplicateTableNameException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheInfo">
            <summary>
            Предоставляет доступ к параметрам кэширования.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheInfo.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.CacheInfo"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheInfo.SetDefault">
            <summary>
            Сбрасывает параметры кэширования до значений по умолчанию.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheInfo.SetFromConfig">
            <summary>
            Сбрасывает параметры кэширования до значений по умолчанию и загружает новые параметры из файла конфигурации приложения.
            </summary>
            <remarks>
            <para>Актуально только при отдельном использовании механизма кэширования, без классов <see cref="T:Nemiro.Data.Sql.SqlClient"/> и ORM.</para>
            <para>Для клиентов баз данных имена параметров содержат имя клиента БД. Например, для SqlClient:
            <list type="bullet">
            <item><description>вместо NeData:CacheType будет NeData:Sql:CacheType;</description></item>
            <item><description>вместо NeData:CacheBufferSize будет NeData:Sql:CacheBufferSize;</description></item>
            <item><description>и т.д.</description></item>
            </list>
            </para>
            <para>В приложениях Windows имена параметров нужно записывать без двоеточий и с учетом регистра.
            Например: 
            <list type="bullet">
            <item><description>вместо NeDataCacheType будет NeDataSqlCacheType;</description></item>
            <item><description>вместо NeDataCacheBufferSize будет NeDataSqlCacheBufferSize;</description></item>
            <item><description>и т.п.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheType">
            <summary>
            Метод кэширования данных. Значение по умолчанию <see cref="F:Nemiro.Data.CachingType.Auto"/>, если иное не указано в параметре <c>NeData:Sql:CacheType</c> файла конфигурации.
            </summary>
            <remarks>
            <para>Не рекомендуется использовать значение <see cref="F:Nemiro.Data.CachingType.Auto"/>, поскольку на автоматическое определение типа кэширования может потребоваться на пару наносекунд больше, чем если метод кэширования будет указан явно.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheCustom">
            <summary>
            Тип пользовательского объекта кэширования. Используется совместно со свойствами <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheType"/> и <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheCustomArgs"/>.
            </summary>
            <remarks>
            <para>Пользовательский класс, реализующий доступ к кэшу, должен быть наследован от <see cref="T:System.Runtime.Caching.ObjectCache"/>.</para>
            <para>Чтобы использовать пользовательский класс для работы с кэшем, свойство <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheType"/> должно иметь значение <see cref="F:Nemiro.Data.CachingType.Custom"/>.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheCustomArgs">
            <summary>
            Массив дополнительных параметров инициализации пользовательского кэша. Эти параметры будут переданы в конструктор пользовательского кэша.
            Используется совместно со свойствами <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheType"/> и <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheCustom"/>.
            </summary>
            <remarks>
            <para>Если конструктор пользовательского кэша принимает параметры инициализации, то их можно указать в виде массива.</para>
            <para>Важно соблюдать порядок элементов в массиве. Элементы массива будут переданы в параметры последовательно. Количество элементов массива должно соответствовать количеству параметров конструктора.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheName">
            <summary>
            Имя ключа элемента кэша, если нужно указать определенный ключ (по умолчанию, формируется автоматически для конкретного запроса).
            </summary>
            <remarks>
            <para>По умолчанию, имя ключа записи кэша формируется автоматически в виде хеш-суммы на основе входящих данных (строки соединения с базой данных, параметров запроса и т.п).</para>
            <para>При необходимости, вы можете указать любое удобное для вас имя записи кэша. Это может быть полезно для реализации механизмов ручного управления кэшем. Например, если нужно будет удалить определенную запись кэша при внесении изменений в зависимые данные.</para>
            <para>
            Стоит отметить, что в файлом кэше (где имена файлов являются ключами записи кэша) указанное в <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheName"/> может быть проигнорировано, если значение 
            содержит недопустимые для файловой системы символы, либо слишком длинное. 
            Однако на работоспособности это не отразится и не вызовет никаких неудобств, просто значение <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheName"/> будет преобразовано в хеш-сумму.
            </para>
            <para>При работе с классом <see cref="T:Nemiro.Data.Sql.SqlClient"/>, ВАЖНО не забывать менять <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheName"/>, если с одним экземляром класса <see cref="T:Nemiro.Data.Sql.SqlClient"/> выполняется серия запросов.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheDuration">
            <summary>
            Продолжительность хранения записи в кэше, в секундах.
            Если это свойство имеет значение <c>0</c> или меньше, кэширование данных не выполняется.
            </summary>
            <remarks>
            <para>
            Если кэш настроен неправильно или недоступен, то кэширование выполняться не будет.
            </para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CachePath">
            <summary>
            Полный физический путь к каталогу хранения файлов кэша, используется только если свойство <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheType"/> имеет значение <see cref="F:Nemiro.Data.CachingType.File"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheInfo.CacheBufferSize">
            <summary>
            Максимальный объем данных (в килобайтах) для дополнительного кэша в памяти (ОЗУ) компьютера. 
            Кэш памяти используется для ускорения работы файлового кэша (<see cref="F:Nemiro.Data.CachingType.File"/>).
            Значение по умолчанию <c>2048</c> Кб (<c>2</c> Мб).
            </summary>
            <remarks>
            <para>Буфер используется только если свойство <see cref="P:Nemiro.Data.Caching.CacheInfo.CacheType"/> имеет значение <see cref="F:Nemiro.Data.CachingType.File"/>.</para>
            <para>
            Данные помещаются в буфер по мере необходимости и при последующих запросах берутся из памяти, что позволяет не делать лишних операций в файловой системе.
            Если какие-то файлы кэша меняются, то эти изменения автоматически отражаются в буфере.
            </para>
            <para>Не рекомендуется менять объем буфера программно, лучше указать его один раз в файле конфигурации приложения.</para>
            <para>
            Буфер реализован на основе коллекции <see cref="T:System.Collections.Hashtable"/>. Работа буфера является потокобезопасной.
            </para>
            <para>
            При использовании кэша в многопоточных приложениях, буфер, на момент записи в него данных, блокируется. 
            Время блокировки не может превышать трех секунд (зацикливание приложения полностью исключено).
            Блокировка необходима для решения известных проблем с доступом к <see cref="T:System.Collections.Hashtable"/> при очень большом количестве асинхронных запросов (сотни, тысячи запросов в секунду).
            Речь об исключении: InvalidOperationException: Hashtable insert failed. Load factor too high. The most common cause is multiple threads writing to the Hashtable simultaneously.
            Если у вас возникнут проблемы в работе кэша: излишние задержки, или может даже показанное выше исключение, то отключите буфер, установив значение <c>0</c>.
            Но как показывает практика, в обычных условиях проблем в работе буфера не возникает. 
            Механизм блокировки был сделан специально для веб-сайтов, которые ежесекундно посещают сотни уникальных пользователей, 
            которые генерируют тысячи ресурсоемких запросов.
            </para>
            </remarks>
        </member>
        <member name="T:Nemiro.Data.DataChangeInfo">
            <summary>
            Предоставляет информацию об изменениях данных.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DataChangeInfo.#ctor(System.String,System.String,System.String,System.Object,System.Object)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.DataChangeInfo"/>.
            </summary>
            <param name="previousValue">Предыдущее значение.</param>
            <param name="currentValue">Текущее значение.</param>
            <param name="columnName">Имя измененного поля таблицы.</param>
            <param name="propertyName">Имя измененного свойства.</param>
            <param name="displayName">Отображаемое имя.</param>
        </member>
        <member name="P:Nemiro.Data.DataChangeInfo.PreviousValue">
            <summary>
            Предыдущее значение.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeInfo.CurrentValue">
            <summary>
            Текущее значение.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeInfo.PropertyName">
            <summary>
            Имя измененного свойства.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeInfo.ColumnName">
            <summary>
            Имя измененного поля таблицы.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeInfo.DisplayName">
            <summary>
            Отображаемое имя.
            </summary>
        </member>
        <member name="T:Nemiro.Data.ColumnAttribute">
            <summary>
            Атрибут указывает, что свойство реализует поле таблицы.
            </summary>
            <remarks>
            <para>Данным атрибутом помечаются свойства классов наследованных от <see cref="T:Nemiro.Data.Sql.BaseObject"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.#ctor(System.String,System.Data.SqlDbType)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ColumnAttribute"/> с указанием имени поля и типа данных SQL Server.
            </summary>
            <param name="columnName">Имя поля таблицы базы данных SQL Server.</param>
            <param name="dataType">Тип данных SQL Server, содержащихся в поле.</param>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.#ctor(System.String,System.Data.SqlDbType,Nemiro.Data.ColumnAttributeFlags)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ColumnAttribute"/> с указанием имени поля, типа данных SQL Server и флагов интерпретации.
            </summary>
            <param name="columnName">Имя поля таблицы базы данных SQL Server.</param>
            <param name="dataType">Тип данных SQL Server, содержащихся в поле.</param>
            <param name="flags">Дополнительные опции поля, определяющие его поведение. Битовая маска <see cref="T:Nemiro.Data.ColumnAttributeFlags"/>.</param>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.#ctor(System.String,System.Object)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ColumnAttribute"/> с указанием имени поля и типа данных.
            </summary>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.#ctor(System.String,System.Object,Nemiro.Data.ColumnAttributeFlags)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ColumnAttribute"/> с указанием имени поля, типа данных и флагов интерпретации.
            </summary>
            <param name="columnName">Имя поля таблицы базы данных.</param>
            <param name="dataType">Тип данных поля в базе.</param>
            <param name="flags">Дополнительные опции поля, определяющие его поведение. Битовая маска <see cref="T:Nemiro.Data.ColumnAttributeFlags"/>.</param>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.#ctor(System.String,System.Object,Nemiro.Data.ColumnAttributeFlags,System.Int32,System.Object)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ColumnAttribute"/> с указанными параметрами.
            </summary>
            <param name="columnName">Имя поля таблицы базы данных.</param>
            <param name="dataType">Тип данных поля в базе.</param>
            <param name="flags">Дополнительные опции поля, определяющие его поведение. Битовая маска <see cref="T:Nemiro.Data.ColumnAttributeFlags"/>.</param>
            <param name="default">Значени по умолчанию.</param>
            <param name="size">Определяет наибольший размер поля (в байтах). Ноль - без ограничений (по умолчанию).</param>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.GetSqlParameter">
            <summary>
            Возвращает параметр SQL Server.
            </summary>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.GetValidParameterValue(System.Reflection.PropertyInfo)">
            <summary>
            Возвращает правильное значение параметра для передачи в базу.
            Для правильной работы нужно вызвать SetOwner.
            </summary>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.GetSqlEmptyValue">
            <summary>
            Возвращает пустое значение для передачи в SQL Server
            </summary>
        </member>
        <member name="M:Nemiro.Data.ColumnAttribute.SetOwner(System.Object)">
            <summary>
            Устанавливает родителя.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.ColumnName">
            <summary>
            Имя колонки, которая реализована в свойстве.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.DataType">
            <summary>
            Тип данных поля. Допускается использование перечисления <see cref="T:System.Data.SqlDbType"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.DisplayName">
            <summary>
            Отображаемое имя (может использоваться при реализации журнала изменений данных).
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.Flags">
            <summary>
            Дополнительные опции поля, определяющие его поведение. Битовая маска <see cref="T:Nemiro.Data.ColumnAttributeFlags"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.Size">
            <summary>
            Определяет наибольший размер поля (в байтах). Ноль - без ограничений (по умолчанию).
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.Default">
            <summary>
            Значение по умолчанию.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.IsPrimaryKey">
            <summary>
            Возвращает <c>True</c>, если <see cref="P:Nemiro.Data.ColumnAttribute.Flags"/> содержит <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.IsUnique">
            <summary>
            Возвращает <c>True</c>, если <see cref="P:Nemiro.Data.ColumnAttribute.Flags"/> содержит <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.IsIdentity">
            <summary>
            Возвращает <c>True</c>, если <see cref="P:Nemiro.Data.ColumnAttribute.Flags"/> содержит <see cref="F:Nemiro.Data.ColumnAttributeFlags.Identity"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.AllowNull">
            <summary>
            Возвращает <c>True</c>, если <see cref="P:Nemiro.Data.ColumnAttribute.Flags"/> содержит <see cref="F:Nemiro.Data.ColumnAttributeFlags.AllowNull"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.ParameterName">
            <summary>
            Содержит имя параметра подстановки в запрос. Например: <c>@col_name</c>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.SqlDbType">
            <summary>
            Содержит тип данных SQL Server, если DataType может быть преобразован в SqlDbType.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.OwnerClassType">
            <summary>
            Тип класса-владельца.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.OwnerClass">
            <summary>
            Ссылка на класс-владельца.
            </summary>
        </member>
        <member name="P:Nemiro.Data.ColumnAttribute.IsSql">
            <summary>
            Вернет true, если используется база данных SQL Server
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheEntryPolicy">
            <summary>
            Представляет сведения о сроке хранения записи кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntryPolicy.#ctor(System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.CacheEntryPolicy"/>.
            </summary>
            <param name="policy">Сведения о хранении записи.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheEntryPolicy.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.CacheEntryPolicy"/>.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheEntryPolicy.AbsoluteExpiration">
            <summary>
            Срок хранения данных в кэше.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheEntryPolicy.SlidingExpiration">
            <summary>
            Срок, по истечению которого нужно удалить запись, если к ней не обращались.
            </summary>
        </member>
        <member name="T:Nemiro.Data.DataHelper">
            <summary>
            Вспомогательный класс для работы с данными.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DataHelper.ContainsColumn(System.Data.DataRow,System.String)">
            <summary>
            Возвращает true, если в строке есть колонка с указанным именем.
            </summary>
            <param name="row">Строка, в которой нужно выполнить поиск колонки.</param>
            <param name="columnName">Имя колонки.</param>
        </member>
        <member name="T:Nemiro.Data.TableNameNullException">
            <summary>
            Исключение возникает, если в атрибуте <see cref="T:Nemiro.Data.TableAttribute"/> не указано имя таблицы (<see cref="P:Nemiro.Data.TableAttribute.TableName"/>).
            </summary>
            <remarks>Для исправления исключения необходимо указать имя таблицы при добавлении атрибута <see cref="T:Nemiro.Data.TableAttribute"/> к классу.</remarks>
            <example>
            <para>В следующем примере, к классу <c>Example</c> добавляет атрибут <see cref="T:Nemiro.Data.TableAttribute"/> с указанием имени таблицы <c>example</c>.</para>
            <code lang="C#">
            [Table("example")]
            class Example : BaseObject
            { }
            </code>
            <code lang="VB">
            &lt;Table("example")&gt;
            Public Class Example 
              Inherits BaseObject
            End Class
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.TableNameNullException.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.TableNameNullException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Sql.SqlAdmin">
            <summary>
            Класс предоставляет доступ к методам управления базой данных SQL Server.
            </summary>
            <remarks>
            <para>В этом классе не используется кэширование результатов выполнения операций.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlAdmin"/> со значениями по умолчанию.
            </summary>    
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.#ctor(System.String)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Sql.SqlAdmin"/> с указанием строки соединения с базой данных.
            </summary>
            <param name="connectionString">Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (.config).
            Например: <c>user id=;password=;data source=(local);initial catalog=</c>
            Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле .config)
            </param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.Dispose">
            <summary>
            Освобождает все ресерсу, занятые объектом.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetSqlServerVersion">
            <summary>
            Возвращает версию экземпляра SQL Server.
            </summary>
            <returns>Возвращает номер версии SQL Server. Например: <c>11.0.3128.0</c>.</returns>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetSqlServerProperty(Nemiro.Data.SqlServerProperties)">
            <summary>
            Возвращает значение указанного свойства экземпляра SQL Server.
            </summary>
            <param name="property">Свойство, значение которого нужно получить.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetSqlServerProprty(System.String)">
            <summary>
            Возвращает значение указанного свойства экземпляра SQL Server.
            </summary>
            <param name="propertyName">Имя свойства.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetAllTablesName">
            <summary>
            Возвращает имена всех таблиц, которые есть в базе данных.
            </summary>
            <remarks>
            <para>Данные получаются методом <see cref="M:System.Data.SqlClient.SqlConnection.GetSchema"/> экземпляра класса <see cref="T:System.Data.SqlClient.SqlConnection"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetAllTables">
            <summary>
            Возвращает список всех таблиц, которые есть в базе.
            </summary>
            <returns>
            <para>Возвращает таблицу со следующими полями:</para>
            <code>
            TABLE_NAME      - имя таблицы;
            TABLE_SCHEMA    - схема;
            TABLE_CATALOG   - имя базы данных;
            TABLE_TYPE      - тип таблицы.
            </code>
            </returns>
            <remarks>
            <para>Данные получаются методом <see cref="M:System.Data.SqlClient.SqlConnection.GetSchema"/> экземпляра класса <see cref="T:System.Data.SqlClient.SqlConnection"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetAllTablesSize">
            <summary>
            Возвращает размер всех таблиц базы данных.
            </summary>
            <returns>
            <para>Возвращает таблицу со следующими полями:</para>
            <code>
            table_name  - имя таблицы;
            rows        - количество строк;
            reserved    - объем зарезервированного пространства;
            data_size   - объем данных;
            index_size  - объем индексов;
            unused      - свободный объем.
            </code>
            </returns>
            <remarks>
            <para>Информация формируется на основе данных, полученных в результате выполнения системной хранимой процедуры <c>sp_spaceused</c>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.TableIsExists(System.String)">
            <summary>
            Проверяет существование указанной таблицы в базе данных.
            </summary>
            <param name="tableName">Имя таблицы, наличие которой нужно проверить.</param>
            <returns>Возвращает <c>True</c>, если таблица существует. В противном случае - <c>False</c>.</returns>
            <remarks>
            <para>Поиск делается по списку таблиц <c>INFORMATION_SCHEMA.TABLES</c>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.TableIsExists(System.String,System.String)">
            <summary>
            Проверяет существование указанной таблицы на сервере.
            </summary>
            <param name="tableName">Имя таблицы, наличие которой нужно проверить</param>
            <param name="tableSchema">Схема</param>
            <returns>Возвращает <c>True</c>, если таблица существует. В противном случае - <c>False</c>.</returns>
            <remarks>
            <para>Поиск делается по списку таблиц <c>INFORMATION_SCHEMA.TABLES</c>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetTableColums(System.String)">
            <summary>
            Возвращает список всех колонок указанной таблицы.
            </summary>
            <param name="tableName">Имя таблицы, информацию о колонках которой нужно получить.</param>
            <remarks>
            <para>Информация формируется на основе метаданных <c>INFORMATION_SCHEMA</c>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.GetTablePrimaryKey(System.String)">
            <summary>
            Возвращает имя основного ключевого поля таблицы.
            </summary>
            <param name="tableName">Имя таблицы, для которой нужно получить имя ключевого поля.</param>
            <returns>
            <para>Возвращает имя ключевого поля таблицы. Если ключевого поля в таблице нет, возвращает пустую строку.</para>
            </returns>
            <remarks>
            <para>Результат формируется на основе данных метода <see cref="M:Nemiro.Data.Sql.SqlAdmin.GetTableColums(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.ResetIdentity(System.String)">
            <summary>
            Сбрасывает в ноль значение числового счетчика у указанной таблицы.
            </summary>
            <param name="tableName">Имя таблицы, которой нужно сбросить значение счетчика.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.SetIdentityValue(System.String,System.Int32)">
            <summary>
            Устанавливает новое значение для числового счетчика у указанной таблицы.
            </summary>
            <param name="tableName">Имя таблицы, которой нужно установить значение счетчика.</param>
            <param name="value">Новое значение счетчика.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.CreateTable(System.Data.DataTable,System.Boolean)">
            <summary>
            Создает таблицу в базе данных.
            </summary>
            <param name="value">Таблица, которую нужно создать в базе данных.</param>
            <param name="includeData">Включить набор данных в таблицу или нет. По умолчанию <c>False</c> - данные не будут добавлены.</param>
            <remarks>
            <para>Если таблица с указанным именем существует в базе данных, то это приведет к возникновению исключения.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.CreateTable(System.Data.DataSet,System.Boolean)">
            <summary>
            Создает таблицы, указанные в экземпляре <see cref="T:System.Data.DataSet"/>.
            </summary>
            <param name="value">Набор данных, содержащий список таблиц, которые нужно создать в базе данных.</param>
            <param name="includeData">Добавить в созданные таблицы, находящиеся в них данные или нет. По умолчанию <c>False</c> - не добавлять.</param>
            <remarks>
            <para>Если хотя бы одна таблица уже существует в базе данных, то это приведет к возникновению исключения. Проверка делается глобально, перед созданием таблиц.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.DeleteTable(System.String)">
            <summary>
            Удаляет указанную таблицу из базы данных.
            </summary>
            <param name="tableName">Имя таблицы, которую нужно удалить.</param>
            <remarks>
            <para>Удаление таблицы производится инструкцией <c>DROP TABLE</c>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlAdmin.ClearTable(System.String)">
            <summary>
            Удаляет все данные из указанной таблицы. Используется инструкция <c>TRUNCATE TABLE</c> (быстрое удаление с минимумом записей в журнал).
            </summary>
            <param name="tableName">Имя таблицы, которую нужно очистить.</param>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlAdmin.ConnectionString">
            <summary>
            Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (<c>*.config</c>).
            Значение по умолчанию: <c>LocalSqlServer</c>.
            </summary>
            <value>Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле <c>*.config</c>).</value>
            <remarks>
            <para>В качестве <see cref="P:Nemiro.Data.Sql.SqlAdmin.ConnectionString"/> можно указывать, как саму строку соединения, так и имя параметра в файле конфигурации.</para>
            <para>По умолчанию используется строка соединения с именем <c>LocalSqlServer</c>.
            В web-приложениях строка соединения с именем <c>LocalSqlServer</c> иметь путь к SQL Server по умолчанию. 
            Для использования параметра <c>LocalSqlServer</c> в веб-приложениях со своей базой данных, которая отличается от базы по умолчанию,
            необходимо удалить <c>LocalSqlServer</c> из файла конфигурации и добавить заново (написать код удаления и добавления):
            </para>
            <code lang="XML">
            &lt;remove name="LocalSqlServer"/&gt;
            &lt;add 
              name="LocalSqlServer" 
              connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
            /&gt;
            </code>
            <para>
            Как правило, изменение строки соединения в процессе разработки приложения при помощи свойства <see cref="P:Nemiro.Data.Sql.SqlAdmin.ConnectionString"/> не требуется.
            Обычно достаточно одной строки соединения. Если же возникает необходимость использовать нестандартную строку (отличную от <c>LocalSqlServer</c>), то её проще указывать при инициализации класса.
            </para>
            <code lang="C#">
            using (SqlAdmin admin = new SqlAdmin(@"Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"))
            {
              // ...
            }
            </code>
            <code lang="VB">
            Using admin As New SqlAdmin("Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;"))
              ' ...
            End Using
            </code>
            </remarks>
        </member>
        <member name="T:Nemiro.Data.Sql.BaseObject">
            <summary>
            Базовый класс, реализующий объектно-ориентированный доступ к данны (Object-Relational Mapping, ORM).
            </summary>
            <remarks>
            <para>От этого класса должны наследоваться все объекты, через которые необходимо осуществлять взаимодействие с базой данных SQL Server.</para>
            <para>
            Классы ORM можно создавать вручную, либо при помощи программы DB2Class3, которую можно найти на страничке проекта: 
            <see href="https://github.com/alekseynemiro/nemiro.data.dll">https://github.com/alekseynemiro/nemiro.data.dll</see>
            </para>
            <para>Работа с данными в базовом классе <see cref="T:Nemiro.Data.Sql.BaseObject"/> реализуется при помощи <see cref="T:Nemiro.Data.Sql.SqlClient"/>.</para>
            <para>
            По умолчанию используется строка соединения <c>LocalSqlServer</c>.
            В качестве <see cref="P:Nemiro.Data.Sql.BaseObject.ConnectionString"/> можно указывать, как саму строку соединения, так и имя параметра в файле конфигурации.
            В web-приложениях строка соединения с именем <c>LocalSqlServer</c> иметь путь к SQL Server по умолчанию. 
            Для использования параметра <c>LocalSqlServer</c> в веб-приложениях со своей базой данных, которая отличается от базы по умолчанию,
            необходимо удалить <c>LocalSqlServer</c> из файла конфигурации и добавить заново (написать код удаления и добавления):
            </para>
            <code lang="XML">
            &lt;remove name="LocalSqlServer"/&gt;
            &lt;add 
              name="LocalSqlServer" 
              connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=example;Trusted_Connection=True;" 
            /&gt;
            </code>
            <para>
            Если указана строка соединения в перегрузке атрибута <see cref="T:Nemiro.Data.TableAttribute"/>, то она будет использоваться при доступе к базе данных.
            </para>
            </remarks>
            <example>
            <para>В следующем примере показано воплощение в классе <c>Users</c> одноименной таблицы.</para>
            <code lang="C#">
            using System;
            using System.Collections.Generic;
            using Nemiro.Data;
            using Nemiro.Data.Sql;
            using System.Data;
            
            [Table("users")]
            public class Users : BaseObject
            {
            
              [Column("id_users", SqlDbType.Int, ColumnAttributeFlags.PrimaryKey | ColumnAttributeFlags.Identity)]
              public int IdUsers { get; set; }
            
              [Column("first_name", SqlDbType.NVarChar, Size = 50)]
              public string FirstName { get; set; }
            
              [Column("last_name", SqlDbType.NVarChar, Size = 50)]
              public string LastName { get; set; }
            
              [Column("email", SqlDbType.VarChar, Size = 100)]
              public string Email { get; set; }
            
              [Column("phone", SqlDbType.VarChar, Size = 30)]
              public string Phone { get; set; }
            
              [Column("sex", SqlDbType.Char, Size = 1)]
              public string Sex { get; set; }
            
              [Column("birthday", SqlDbType.DateTime, ColumnAttributeFlags.AllowNull)]
              public DateTime? Birthday { get; set; }
            
              [Column("date_created", SqlDbType.DateTime, Default = ColumnDefaultValues.Now)]
              public DateTime DateCreated { get; set; }
            
            }
            </code>
            <code lang="VB">
            Imports System.Collections.Generic
            Imports Nemiro.Data
            Imports Nemiro.Data.Sql
            Imports System.Data
            
            &lt;Table("users")&gt; _
            Public Class Users
              Inherits BaseObject
              
              &lt;Column("id_users", SqlDbType.Int, ColumnAttributeFlags.PrimaryKey Or ColumnAttributeFlags.Identity)&gt; _
              Public Property IdUsers() As Integer
            
              &lt;Column("first_name", SqlDbType.NVarChar, Size := 50)&gt; _
              Public Property FirstName() As String
            
              &lt;Column("last_name", SqlDbType.NVarChar, Size := 50)&gt; _
              Public Property LastName() As String
            
              &lt;Column("email", SqlDbType.VarChar, Size := 100)&gt; _
              Public Property Email() As String
            
              &lt;Column("phone", SqlDbType.VarChar, Size := 30)&gt; _
              Public Property Phone() As String
            
              &lt;Column("sex", SqlDbType.[Char], Size := 1)&gt; _
              Public Property Sex() As String
            
              &lt;Column("birthday", SqlDbType.DateTime, ColumnAttributeFlags.AllowNull)&gt; _
              Public Property Birthday() As System.Nullable(Of DateTime)
            
              &lt;Column("date_created", SqlDbType.DateTime, [Default] := ColumnDefaultValues.Now)&gt; _
              Public Property DateCreated() As DateTime
            
            End Class
            </code>
            <para>Теперь, когда есть класс реализующий доступ к таблице <c>users</c>, можно работать с данными через этот объект.</para>
            <para>Если таблица <c>users</c> в базе данных не существует, её можно легко создать, как показано в следующем примере.</para>
            <code lang="C#">
            // создаем экземпляр класса Users
            Users u = new Users();
            // проверяем существование таблицы в базе данных
            if (!u.TableExists())
            {
              // таблицы не существует, создаем
              u.CreateTable();
            }
            </code>
            <code lang="VB">
            ' создаем экземпляр класса Users
            Dim u As New Users()
            ' проверяем существование таблицы в базе данных
            If Not u.TableExists() Then
              ' таблицы не существует, создаем
              u.CreateTable()
            End If
            </code>
            <para>
            Однако, постоянно проверять существование таблиц в базе данных не рекомендуется, т.к. эта операция занимает определенное время.
            Это можно сделать один раз, например, при запуске приложения, 
            если речь идет о веб-проекте. В приложениях Windows, 
            подобный метод создания таблиц можно реализовать, например, при установке приложения. 
            </para>
            <para>
            Работа непосредственно с данными осуществляется при помощи трех простых методов: <see cref="M:Nemiro.Data.Sql.BaseObject.Load"/>, <see cref="M:Nemiro.Data.Sql.BaseObject.Save"/> и <see cref="M:Nemiro.Data.Sql.BaseObject.Delete"/>.
            </para>
            <para>
            В следующем примере показано добавление в таблицу <c>users</c> двух пользователей.
            Данные добавляются после вызова метода <see cref="M:Nemiro.Data.Sql.BaseObject.Save"/>.
            </para>
            <code lang="C#">
            // создаем экземпляр класса Users
            Users u = new Users();
            // указываем данные пользователя
            u.FirstName = "Василий";
            u.LastName = "Пупкин";
            u.Sex = "M";
            u.Email = "pupkin@example.org";
            u.Birthday = new DateTime(1980, 1, 1);
            // сохраняем пользователя в базе данных
            u.Save();
            
            // выводим результат
            Console.WriteLine("Пользователь успешно сохранен в базу. Идентификатор пользователя: {0}", u.IdUsers);
            
            // создаем экземпляр класса Users
            u = new Users();
            // указываем данные пользователя
            u.FirstName = "Маша";
            u.LastName = "Иванова";
            u.Sex = "F";
            u.Email = "ivanova@example.org";
            u.Birthday = new DateTime(1985, 10, 15);
            // сохраняем пользователя в базе данных
            u.Save();
            
            // выводим результат
            Console.WriteLine("Пользователь успешно сохранен в базу. Идентификатор пользователя: {0}", u.IdUsers);
            </code>
            <code lang="VB">
            ' создаем экземпляр класса Users
            Dim u As New Users()
            ' указываем данные пользователя
            u.FirstName = "Василий"
            u.LastName = "Пупкин"
            u.Sex = "M"
            u.Email = "pupkin@example.org"
            u.Birthday = new DateTime(1980, 1, 1)
            ' сохраняем пользователя в базе данных
            u.Save()
            
            ' выводим результат
            Console.WriteLine("Пользователь успешно сохранен в базу. Идентификатор пользователя: {0}", u.IdUsers)
            
            ' создаем экземпляр класса Users
            u = New Users()
            ' указываем данные пользователя
            u.FirstName = "Маша"
            u.LastName = "Иванова"
            u.Sex = "F"
            u.Email = "ivanova@example.org"
            u.Birthday = new DateTime(1985, 10, 15)
            ' сохраняем пользователя в базе данных
            u.Save()
            
            ' выводим результат
            Console.WriteLine("Пользователь успешно сохранен в базу. Идентификатор пользователя: {0}", u.IdUsers)
            </code>
            <para>Каждая запись в базе данных имеет уникальный идентификатор - ключ. 
            В нашем случае, ключом является поле <c>id_users</c> таблицы <c>users</c>.
            В классе <c>Users</c> об этом свидетельствуют атрибуты <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> и
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.Identity"/>.
            После добавления пользователя в базу, свойство <c>IdUsers</c> экземпляра класса <c>Users</c> 
            получает из базы значение идентификатора записи.
            По этому идентификатору можно получить доступ к данным конкретного пользователя.
            </para>
            <code lang="C#">
            // создаем экземпляр класса Users
            Users u = new Users();
            // указываем в ключевое поле идентификатор пользователя
            u.IdUsers = 1;
            // загружаем в класс данные пользователя по указанному идентификатору
            u.Load();
            
            // выводим полученные данные пользователя в консоль
            Console.WriteLine("Имя:\t\t {0} {1}", u.FirstName, u.LastName);
            Console.WriteLine("Пол:\t\t {0}", u.Sex);
            Console.WriteLine("Дата рождения:\t {0}", u.Birthday.Value.ToShortDateString());
            Console.WriteLine("Email:\t\t {0}", u.Email);
            </code>
            <code lang="VB">
            ' создаем экземпляр класса Users
            Dim u As New Users()
            ' указываем в ключевое поле идентификатор пользователя
            u.IdUsers = 1
            ' загружаем в класс данные пользователя по указанному идентификатору
            u.Load()
            
            ' выводим полученные данные пользователя в консоль
            Console.WriteLine("Имя:\t\t {0} {1}", u.FirstName, u.LastName)
            Console.WriteLine("Пол:\t\t {0}", u.Sex)
            Console.WriteLine("Дата рождения:\t {0}", u.Birthday.Value.ToShortDateString())
            Console.WriteLine("Email:\t\t {0}", u.Email)
            </code>
            <para>
            Когда указан идентификатор, вызов метода <see cref="M:Nemiro.Data.Sql.BaseObject.Save"/> не будет создавать новую запись, 
            а сохранит изменения в загруженной записи.
            </para>
            <code lang="C#">
            // создаем экземпляр класса Users
            Users u = new Users();
            // указываем в ключевое поле идентификатор пользователя
            u.IdUsers = 1;
            // загружаем в класс данные пользователя по указанному идентификатору
            u.Load();
            // после вызова метода Load, можно проверить, 
            // были ли получен данные или нет
            if (u.IdUsers &lt;= 0)
            {
              // идентификатор обнулен, значит данные в базе не найдены
              Console.WriteLine("Пользователь не найден.");
              return; // выходим из программы
            }
            // данные пользователя успешно получены
            // выводим в консоль идентификатор 
            Console.WriteLine("Получены данные для пользователя: {0}", u.IdUsers);
            // меняем данные пользователя
            u.FirstName = "Федя";
            u.LastName = "Петров";
            // сохраняем данные пользователя
            u.Save();
            // выводим в консоль идентификатор сохраненного пользователя
            Console.WriteLine("Данные пользователя {0} успешно записаны в базу", u.IdUsers);
            </code>
            <code lang="VB">
            ' создаем экземпляр класса Users
            Dim u As New Users()
            ' указываем в ключевое поле идентификатор пользователя
            u.IdUsers = 1
            ' загружаем в класс данные пользователя по указанному идентификатору
            u.Load()
            ' после вызова метода Load, можно проверить, 
            ' были ли получен данные или нет
            If u.IdUsers &lt;= 0 Then
              ' идентификатор обнулен, значит данные в базе не найдены
              Console.WriteLine("Пользователь не найден.")
              Return ' выходим из программы
            End If
            ' данные пользователя успешно получены
            ' выводим в консоль идентификатор 
            Console.WriteLine("Получены данные для пользователя: {0}", u.IdUsers)
            ' меняем данные пользователя
            u.FirstName = "Федя"
            u.LastName = "Петров"
            ' сохраняем данные пользователя
            u.Save()
            ' выводим в консоль идентификатор сохраненного пользователя
            Console.WriteLine("Данные пользователя {0} успешно записаны в базу", u.IdUsers)
            </code>
            <para>Базовый класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> имеет перегрузки, которые позволяют еще больше упростить доступ к данным.</para>
            <para>Используйте программу <see href="https://github.com/alekseynemiro/nemiro.data.dll">DB2Class3</see>, 
            чтобы автоматически создавать более удобные классы для доступа к данным.</para>
            </example>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor">
            <summary>
            Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> со значениями по умолчанию.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor(System.Data.DataRow)">
            <summary>
            Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> на основе указанной строки данных.
            </summary>
            <param name="row">Строка данных, из которой будут установлены значения свойствам экземпляра класса.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor(System.Object)">
            <summary>
            Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> на основе данных из базы данных по указанному идентификатору.
            </summary>
            <param name="primaryKeyValue">Значение ключевого поля, по которому будут получены данные из базы.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor(System.Object,System.Int32)">
            <summary>
            Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> на основе данных из базы данных по указанному идентификатору с использованием кэширования.
            </summary>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один или ноль - без кэширования (по умолчанию).</param>
            <param name="primaryKeyValue">Значение ключевого поля, по которому будут получены данные из базы.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor(System.Object,Nemiro.Data.Caching.CacheInfo)">
            <summary>
            ызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> на основе данных из базы данных по указанному идентификатору с использованием заданных параметров кэширования.
            </summary>
            <param name="cache">Параметры кэширования, если требуется указать параметры отличные от значений по умолчанию для экземпляра <see cref="T:Nemiro.Data.Sql.SqlClient"/>. Если <c>NULL</c> (<c>Nothing</c>), то будут использоваться параметры по умолчанию.</param>
            <param name="primaryKeyValue">Значение ключевого поля, по которому будут получены данные из базы.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.#ctor(System.Data.DataRow,System.Object,System.Int32,Nemiro.Data.Caching.CacheInfo)">
            <summary>
            Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:Nemiro.Data.Sql.BaseObject"/> со значениями, указанными в параметрах.
            </summary>
            <param name="cacheDuration">Продолжительность кэширования результатов запроса, в секундах. Минус один или ноль - без кэширования (по умолчанию). Если указан параметр <paramref name="cache"/>, то приоритетно будет использоваться значение из <paramref name="cache"/>.</param>
            <param name="row">Строка данных, из которой будут установлены значения свойствам экземпляра класса.</param>
            <param name="primaryKeyValue">Значение ключевого поля, по которому будут получены данные из базы. Используется только если <paramref name="row"/> имеет значение <c>NULL</c> (<c>Nothing</c>).</param>
            <param name="cache">Параметры кэширования, если требуется указать параметры отличные от значений по умолчанию для <see cref="T:Nemiro.Data.Sql.SqlClient"/>. Если <c>NULL</c> (<c>Nothing</c>), то будут использоваться параметры по умолчанию.</param>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.Load">
            <summary>
            Загружает в производный класс данные из базы данных по ключевому полю, либо уникальным полям.
            </summary>
            <exception cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">Исключение возникает, если в производном классе не найдено ни одного свойства с флагами
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.Load(System.Data.DataRow)">
            <summary>
            Загружает в производный класс данные из указанного экземпляра <see cref="T:System.Data.DataRow"/>.
            </summary>
            <param name="row">Строка данных из которой нужно переместить данные в свойства производного класса.</param>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.Save">
            <summary>
            Сохраняет данные производного класса класса в базу данных.
            </summary>
            <remarks>
            <para>
            Кэширование не используется.
            Значения свойств <see cref="P:Nemiro.Data.Sql.BaseObject.CacheDuration"/> и <see cref="P:Nemiro.Data.Sql.BaseObject.Cache"/> игнорируются.
            </para>
            <para>Для сохранения объекта в базе данных используется один, динамически построенный, SQL-запрос.</para>
            <para>Проверка существования данных в таблице производится при помощи оператора <c>EXISTS</c> на стороне SQL Server.</para>
            <para>Запрос выглядит примерно так:
            <code lang="SQL">
            IF EXISTS(SELECT [id] FROM [tableName] WHERE [id] = @id) BEGIN
              UPDATE [tableName] SET [field1] = @field1, ... [field9] = @field9 WHERE [id] = @id;
            END
            ELSE BEGIN
              INSERT INTO [tableName] ([field1], ... [field9]) 
              VALUES (@field1, ... @field9);
              -- используется только при наличии числовых идентификаторов
              -- для GUID ключ генерируется отдельно, если необходимо
              SELECT SCOPE_IDENTITY();
            END;
            </code>
            </para>
            </remarks>
            <exception cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">Исключение возникает, если в производном классе не найдено ни одного свойства с флагами
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.Delete">
            <summary>
            Удаляет данные производного класса из базы данных. 
            </summary>
            <returns>Возвращает количество удаленных данных.</returns>
            <exception cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">Исключение возникает, если в производном классе не найдено ни одного свойства с флагами
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.CreateTable">
            <summary>
            Создает в базе данных таблицу на основе схемы, описанной в экземпляре производного класса.
            </summary>
            <exception cref="T:Nemiro.Data.DuplicateTableNameException">Если таблица с указанным именем уже существует в базе данных.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.TableExists">
            <summary>
            Проверяет существование в базе данных таблицы, описанной в экземпляре производного класса.
            </summary>
            <returns>Возвращает <c>True</c>, если таблица существует. В противном случае - <c>False</c>.</returns>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.Exists">
            <summary>
            Проверяет существование данных в базе данных и возвращает <c>True</c>, если данные существуют, в противном случае - <c>False</c>.
            </summary>
            <returns>
            <para><c>True</c> - запись по ключевому полю, либо уникальным полям класса есть в базе данных.</para>
            <para><c>False</c> - записей в базе данных нет.</para>
            </returns>
            <remarks>
            <para>
            Кэширование не используется.
            Значения свойств <see cref="P:Nemiro.Data.Sql.BaseObject.CacheDuration"/> и <see cref="P:Nemiro.Data.Sql.BaseObject.Cache"/> игнорируются.
            </para>
            </remarks>
            <exception cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">Исключение возникает, если в производном классе не найдено ни одного свойства с флагами
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.GetChanges(System.StringComparison)">
            <summary>
            Возвращает информацию об изменении значений полей.
            Имеет смысл использовать только совместно с методом <see cref="M:Nemiro.Data.Sql.BaseObject.Load"/>.
            </summary>
            <param name="stringComparisonType">Тип сравнения строк. По умолчанию без учета регистра символов.</param>
            <returns>Возвращает коллекцию измененных полей.</returns>
            <remarks>
            <para>Метод сравнивает текущие значения свойств со значениями полученнымы из базы данных (свойство <see cref="P:Nemiro.Data.Sql.BaseObject.RowData"/>), после вызова метода <see cref="M:Nemiro.Data.Sql.BaseObject.Load"/>.</para>
            <para>Проверяются только поля с атрибутом <see cref="T:Nemiro.Data.ColumnAttribute"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.ToXml">
            <summary>
            Сериализует экземпляр производного класса в XML.
            </summary>
            <returns>Возвращает строку, содержащую текущий экземпляр производного класса в виде набора xml-данных.</returns>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.ToXml(System.Text.Encoding)">
            <summary>
            Сериализует экземпляр производного класса в XML с использованием определенной кодировки.
            </summary>
            <param name="encoding">Кодировка, которая будет использована при сериализаци.</param>
            <returns>Возвращает строку, содержащую текущий экземпляр производного класса в виде набора xml-данных.</returns>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.ToXml(System.Text.Encoding,System.Xml.Formatting)">
            <summary>
            Сериализует экземпляр производного класса в XML с использованием определенной кодировки и параметров форматирования xml-документа.
            </summary>
            <param name="encoding">Кодировка, которая будет использована при сериализаци.</param>
            <param name="formating">Тип форматирования xml-документа.</param>
            <returns>Возвращает строку, содержащую текущий экземпляр производного класса в виде набора xml-данных.</returns>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)">
            <summary>
            Загружает данные из XML-документа в экземпляр производного класса.
            </summary>
            <param name="xml">Набор xml-данных, которые нужно загрузить в текущий экземпляр класса.</param>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToXml"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String,System.Text.Encoding)">
            <summary>
            Загружает данные из XML-документа в экземпляр производного класса с использованием определенной кодировки.
            </summary>
            <param name="xml">Набор xml-данных, которые нужно загрузить в текущий экземпляр класса.</param>
            <param name="encoding">Кодировка, которая будет использлваться при обработке xml-данных.</param>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToXml"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.ToJson">
            <summary>
            Сериализует экземпляр производного класса в JSON.
            </summary>
            <returns>Возвращает строку, содержащую экземпляр производного класса в формате JSON.</returns>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToXml"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)">
            <summary>
            Загружает данные из JSON в экземпляр производного класса.
            </summary>
            <param name="json">Данные в формате JSON, которые нужно загрузить в экземпляр производного класса.</param>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToXml"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.ToString">
            <summary>
            Возвращает экземпляр производного класса в виде строки в формате JSON.
            </summary>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToJson"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadJson(System.String)"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.ToXml"/>
            <seealso cref="M:Nemiro.Data.Sql.BaseObject.LoadXml(System.String)"/>
        </member>
        <member name="M:Nemiro.Data.Sql.BaseObject.GetList(System.Type,System.Int32,System.Int32,System.String[],System.Object,System.String)">
            <summary>
            Возвращает коллекцию экземпляров производного класса записей БД.
            </summary>
            <param name="T">Тип сущности.</param>
            <param name="page">Страница, начиная с 1.</param>
            <param name="recordsPerPage">Количество записей на одной странице. Если ноль, то будут возвращены все записи.</param>
            <param name="includeFields">Список полей, которые нужно включить в запрос. По умолчанию включены все поля.</param>
            <param name="sort">Порядок сортировки записей.</param>
            <param name="filter">Фильтр. При указании фильтра, в запрос будет добавлена конструкция <c>WHERE</c> с указанием содержимого <paramref name="filter"/> как есть.</param>
            <returns>
            Возвращает коллекцию экземпляров производного класса.
            </returns>
            <remarks>
            <para>
            Используйте методы <see cref="M:Nemiro.Data.DataObjectCollection`1.NextPage"/> и <see cref="M:Nemiro.Data.DataObjectCollection`1.PreviousPage"/>
            для получения коллекции объектов следующей и предыдущей страницы.
            </para>
            <para>
            Для получения сведений об общем количестве записей в базе, используйте свойство <see cref="P:Nemiro.Data.DataObjectCollection`1.TotalRecords"/>.
            </para>
            <para>
            Информация о текущей странице находится в свойстве <see cref="P:Nemiro.Data.DataObjectCollection`1.CurrentPage"/>.
            </para>
            <para>
            При запросе данных с разбивкой на страницы используется оптимальный SQL-запрос, 
            который сначала получает список идентификаторов во временную таблицу,
            а за тем разбивает список на страницы и получает остальные данные для выбранного диапазона.
            Все это производится в одном запросе SQL, на уровне SQL Server.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Исключение возникает, если значение <paramref name="T"/> равно <c>NULL</c> (<c>Nothing</c>).</exception>
            <exception cref="T:Nemiro.Data.NoPrimaryKeyOrUniqueFieldsException">Исключение возникает, если в производном классе не найдено ни одного свойства с флагами
            <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/> или <see cref="F:Nemiro.Data.ColumnAttributeFlags.Unique"/>.</exception>
            <exception cref="T:Nemiro.Data.MoreThanOnePrimaryKeyException">Исключение возникает, если в классе обнаружено более одного свойства с флагом <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/>.</exception>
            <exception cref="T:System.Data.SqlClient.SqlException">Исключение возникает при возврате SQL Server предупреждения или ошибки.</exception>
        </member>
        <member name="P:Nemiro.Data.Sql.BaseObject.ConnectionString">
            <summary>
            Строка соединения с базой данных. Либо имя строки соединения в файле конфигурации (<c>*.config</c>).
            Значение по умолчанию: <c>LocalSqlServer</c>.
            </summary>
            <value>Значение по умолчанию: <c>LocalSqlServer</c> (имя ключа строки соединения в файле <c>*.config</c>).</value>
        </member>
        <member name="P:Nemiro.Data.Sql.BaseObject.RowData">
            <summary>
            Получает строку данных, на основе которой построен текущий экземпляр объекта.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Sql.BaseObject.TableName">
            <summary>
            Содержит имя таблицы объекта.
            </summary>
            <seealso cref="T:Nemiro.Data.TableAttribute"/>
        </member>
        <member name="P:Nemiro.Data.Sql.BaseObject.CacheDuration">
            <summary>
            Продолжительность хранения записи в кэше, в секундах.
            Если это свойство имеет значение <c>0</c> или меньше, кэширование не выполняется.
            </summary>
            <remarks>
            <para>Будьте очень осторожны при использовании кэширования. Не используйте методы <see cref="M:Nemiro.Data.Sql.BaseObject.Save"/> и <see cref="M:Nemiro.Data.Sql.BaseObject.Delete"/>, если данные были получены с применением кэширования.</para>
            </remarks>
            <seealso cref="P:Nemiro.Data.Sql.BaseObject.Cache"/>
        </member>
        <member name="P:Nemiro.Data.Sql.BaseObject.Cache">
            <summary>
            Предоставляет доступ к параметрам кэширования данных.
            </summary>
            <remarks>
            <para>Будьте очень осторожны при использовании кэширования. Не используйте методы <see cref="M:Nemiro.Data.Sql.BaseObject.Save"/> и <see cref="M:Nemiro.Data.Sql.BaseObject.Delete"/>, если данные были получены с применением кэширования.</para>
            </remarks>
            <seealso cref="P:Nemiro.Data.Sql.BaseObject.CacheDuration"/>
        </member>
        <member name="T:Nemiro.Data.CachingType">
            <summary>
            Перечисление методов кэширования результатов выполнения запросов к базе данных.
            </summary>
        </member>
        <member name="F:Nemiro.Data.CachingType.None">
            <summary>
            Не использовать кэширование.
            </summary>
        </member>
        <member name="F:Nemiro.Data.CachingType.Auto">
            <summary>
            Автоматическое определение (по умолчанию).
            </summary>
            <remarks>
            <para>Для веб-проектов будет использоваться <see cref="F:Nemiro.Data.CachingType.Web"/>, для остальных типов проектов - <see cref="F:Nemiro.Data.CachingType.File"/>.</para>
            <para>Не рекомендуется использовать этот режим, лучше указывать тип кэширования явно, в настройках приложения (см. файлы <c>.config</c>).</para>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.CachingType.Web">
            <summary>
            Веб-кэш, только для проектов ASP .NET.
            </summary>
            <remarks>
            <para>Данный метод работает только веб-проектах. В других типах проектов этот механизм кэширования недоступен.</para>
            <para>Кэш <see cref="F:Nemiro.Data.CachingType.Web"/> является потоком зависимым, это значит, что в потоках к нему нет доступа.</para>
            <para>Наилучшим решением этой проблемы будет использование файлового кэша - <see cref="F:Nemiro.Data.CachingType.File"/>.</para>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.CachingType.File">
            <summary>
            Файловый кэш.
            </summary>
        </member>
        <member name="F:Nemiro.Data.CachingType.Memory">
            <summary>
            Кэширование в памяти.
            </summary>
            <remarks>
            <para>Не используйте этот тип кэширования в веб-проектах. Из-за особенностей работы рабочих процессов IIS, кэш в памяти может работать нестабильно.</para>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.CachingType.Custom">
            <summary>
            Пользовательский механизм кэширования.
            </summary>
        </member>
        <member name="T:Nemiro.Data.ConnectionMode">
            <summary>
            Режим подключения к базе данных.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ConnectionMode.Auto">
            <summary>
            Автоматически открывать и закрывать соединение с базой (рекомендуется). Используется по умолчанию.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ConnectionMode.Manual">
            <summary>
            Вручную закрывать соединение с базой.
            </summary>
            <remarks>
            <para>Открытие соединений с базой данных при ручном режиме производится автоматически, при первой необходимости.</para>
            </remarks>
        </member>
        <member name="T:Nemiro.Data.SqlServerProperties">
            <summary>
            Список свойств экземпляра SQL Server.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.BuildClrVersion">
            <summary>
            Версия среды CLR Microsoft.NET Framework, которая использовалась при построении экземпляра SQL Server.
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.Collation">
            <summary>
            Имя параметров сортировки для сервера, установленного по умолчанию.
            </summary>
            <remarks>
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.CollationID">
            <summary>
            Идентификатор параметров сортировки SQL Server.
            </summary>
            <remarks>Базовый тип данных: int</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ComparisonStyle">
            <summary>
            Стиль сравнения Windows параметров сортировки.
            </summary>
            <remarks>Базовый тип данных: int</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ComputerNamePhysicalNetBIOS">
            <summary>
            Имя NetBIOS для локального компьютера, на котором работает экземпляр SQL Server.
            Для кластеризованного экземпляра SQL Server на отказоустойчивом кластере это значение изменяется, когда экземпляр SQL Server переключается на другие узлы в отказоустойчивом кластере.
            Для изолированного экземпляра SQL Server это значение остается постоянным и совпадает со значением, возвращаемым свойством MachineName.
            </summary>
            <remarks>
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.Edition">
            <summary>
            Установленный выпуск экземпляра SQL Server. Используйте значение этого свойства для определения функций и ограничений, таких как Вычисление производительности выпуска SQL Server. В 64-разрядных версиях компонента Компонент Database Engine к обозначению версии добавляется «(64-разрядная версия)». 
            </summary>
            <remarks>
            Сервер возвращает одно из следующих значений: 
            <list type="bullet">
            <item><description>выпуск «Enterprise Edition»;</description></item>
            <item><description>выпуск «Enterprise Edition: лицензирование по числу ядер»;</description></item>
            <item><description>выпуск «Enterprise Evaluation Edition»;</description></item>
            <item><description>выпуск «Business Intelligence»;</description></item>
            <item><description>выпуск «Developer Edition»;</description></item>
            <item><description>выпуск «Express Edition»;</description></item>
            <item><description>выпуск «Express Edition with Advanced Services»; </description></item>
            <item><description>выпуск «Standard Edition»;</description></item>
            <item><description>«Web Edition».</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.EditionID">
            <summary>
            EditionID представляет установленный выпуск продукта для экземпляра SQL Server. Используйте значение этого свойства для определения функций и ограничений, таких как Вычисление производительности выпуска SQL Server.
            См. перечисление SqlServerEditionIDs.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.EngineEdition">
            <summary>
            Выпуск компонента Компонент Database Engine для экземпляра SQL Server, установленного на сервере.
            </summary>
            <seealso cref="T:Nemiro.Data.SqlServerEngineEditionList"/>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.HadrManagerStatus">
            <summary>
            Показывает, запущен ли диспетчер Группы доступности AlwaysOn.
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>0 = не запущен, ожидает связи;</description></item>
            <item><description>1 = запущен и выполняется;</description></item>
            <item><description>2 = не запущен и завершился неудачно.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.InstanceName">
            <summary>
            Имя экземпляра, к которому подключен пользователь.
            </summary>
            <remarks>
            Возвращает значение NULL в случае, если имя экземпляра установлено по умолчанию, при возникновении ошибки и в случае, если входные данные оказываются недопустимы. 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsClustered">
            <summary>
            Экземпляр сервера настроен для работы в отказоустойчивом кластере.
            </summary>
            <remarks>
            1 = в кластере. 
            0 = не в кластере. 
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsFullTextInstalled">
            <summary>
            На текущем экземпляре SQL Server установлены компоненты полнотекстового и семантического индексирования.
            </summary>
            <remarks>
            1 = компоненты полнотекстового и семантического индексирования установлены. 
            0 = компоненты полнотекстового и семантического индексирования не установлены. 
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsHadrEnabled">
            <summary>
            Служба Группы доступности AlwaysOn включена на этом экземпляре сервера.
            </summary>
            <remarks>
            0 = компонент Группы доступности AlwaysOn отключен. 
            1 = компонент Группы доступности AlwaysOn включен.
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsIntegratedSecurityOnly">
            <summary>
            Сервер запущен во встроенном режиме безопасности.
            </summary>
            <remarks>
            1 = встроенная безопасность (проверка подлинности Windows) 
            0 = без встроенного режима безопасности. (Как проверка подлинности Windows, так и проверки подлинности SQL Server.) 
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsLocalDB">
            <summary>
            Сервер является экземпляром SQL Server Express LocalDB.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.IsSingleUser">
            <summary>
            Server запущен в однопользовательском режиме.
            </summary>
            <remarks>
            1 = однопользовательский режим. 
            0 = не однопользовательский режим. 
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.LCID">
            <summary>
            Код языка Windows для параметров сортировки.
            </summary>
            <remarks>Базовый тип данных: int</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.LicenseType">
            <summary>
            Не используется. В продукте SQL Server не сохраняются сведения о лицензии. Всегда возвращает DISABLED.
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.MachineName">
            <summary>
            Имя компьютера Windows, на котором запущен экземпляр сервера.
            </summary>
            <remarks>
            Для кластеризованного экземпляра SQL Server, работающего на виртуальном сервере службы кластеров (Майкрософт), возвращается имя виртуального сервера. 
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.NumLicenses">
            <summary>
            Не используется. В продукте SQL Server не сохраняются сведения о лицензии. 
            </summary>
            <remarks>Всегда возвращает значение NULL.</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ProcessID">
            <summary>
            Идентификатор процесса службы SQL Server. Свойство ProcessID позволяет определить, какой из файлов Sqlservr.exe принадлежит данному экземпляру.
            </summary>
            <remarks>
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: int
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ProductVersion">
            <summary>
            Версия экземпляра SQL Server в формате 'major.minor.build.revision'.
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ProductLevel">
            <summary>
            Уровень версии экземпляра SQL Server.
            </summary>
            <remarks>
            Сервер возвращает одно из следующих значений. 
            RTM = Исходная выпущенная версия 
            SPn = версия пакета обновления 
            CTP = CTP-версия 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ResourceLastUpdateDateTime">
            <summary>
            Отображаются дата и время последнего изменения базы данных Resource.
            </summary>
            <remarks>Базовый тип данных: datetime</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ResourceVersion">
            <summary>
            Возвращает версию базы данных Resource.
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.ServerName">
            <summary>
            Сведения об экземпляре и сервере Windows, связанные с определенным экземпляром SQL Server.
            </summary>
            <remarks>
            NULL = недопустимый ввод или произошла ошибка. 
            Базовый тип данных: nvarchar(128)
            </remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.SqlCharSet">
            <summary>
            Идентификатор кодировки SQL из идентификатора параметров сортировки.
            </summary>
            <remarks>Базовый тип данных: tinyint</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.SqlCharSetName">
            <summary>
            Имя кодировки SQL из параметров сортировки.
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.SqlSortOrder">
            <summary>
            Идентификатор порядка сортировки SQL из параметров сортировки
            </summary>
            <remarks>Базовый тип данных: tinyint</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.SqlSortOrderName">
            <summary>
            Имя порядка сортировки SQL из параметров сортировки
            </summary>
            <remarks>Базовый тип данных: nvarchar(128)</remarks>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.FilestreamShareName">
            <summary>
            Имя общего ресурса, используемое FILESTREAM.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.FilestreamConfiguredLevel">
            <summary>
            Настроенный уровень доступа FILESTREAM.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerProperties.FilestreamEffectiveLevel">
            <summary>
            Действующий уровень доступа FILESTREAM. Это значение может отличаться от значения FilestreamConfiguredLevel, если уровень был изменен и ожидается перезапуск экземпляра или перезагрузка компьютера.
            </summary>
        </member>
        <member name="T:Nemiro.Data.SqlServerEditionIDs">
            <summary>
            Список редакций SQL Server.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.Enterprise">
            <summary>
            Enterprise Edition
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.EnterpriseEdition">
            <summary>
            Enterprise Edition
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.EnterpriseEvaluation">
            <summary>
            Enterprise Evaluation
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.BusinessIntelligence">
            <summary>
            Business Intelligence
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.Developer">
            <summary>
            Developer Edition
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.Express">
            <summary>
            Express Edition
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.ExpressWithAdvancedServices">
            <summary>
            Express Edition with Advanced Services
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.Standard">
            <summary>
            Standard Edition
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEditionIDs.Web">
            <summary>
            Web Edition
            </summary>
        </member>
        <member name="T:Nemiro.Data.SqlServerEngineEditionList">
            <summary>
            Перечень редакций SQL Server.
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEngineEditionList.PersonalOrDesktopEngine">
            <summary>
            Personal или Desktop Engine (недоступен для SQL Server 2005 и более поздних версий).
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEngineEditionList.Standard">
            <summary>
            Standard (возвращается для выпусков Standard, Web и Business Intelligence).
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEngineEditionList.Enterprise">
            <summary>
            Enterprise (это значение возвращается для выпусков Evaluation Edition, Developer Edition и обоих вариантов Enterprise Edition).
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEngineEditionList.Express">
            <summary>
            Express (возвращается для выпусков Express, Express с инструментами и Express с дополнительными службами).
            </summary>
        </member>
        <member name="F:Nemiro.Data.SqlServerEngineEditionList.SQLAzure">
            <summary>
            SQL Azure
            </summary>
        </member>
        <member name="T:Nemiro.Data.TypeCommand">
            <summary>
            Перечень типов команд.
            </summary>
        </member>
        <member name="F:Nemiro.Data.TypeCommand.Auto">
            <summary>
            Автоматическое определение (по умолчанию).
            </summary>
            <remarks>
            <para>Определение происходит по наличию в тексте команды популярных инструкций, 
            таких как: <c>SELECT FROM, INSERT INTO, UPDATE SET, DELETE FROM.</c>
            </para>
            <para><see cref="F:Nemiro.Data.TypeCommand.TableDirect"/> при автоопределении никогда не будет использоваться.</para>
            <para>Если запрос не является известной инструкцией SQL, не содержит пробелов и точек с запятой (;), то будет использоваться <see cref="F:Nemiro.Data.TypeCommand.StoredProcedure"/>.</para>
            <para>В остальных случаях, всегда будет использоваться <see cref="F:Nemiro.Data.TypeCommand.Text"/>.</para>
            </remarks>
        </member>
        <member name="F:Nemiro.Data.TypeCommand.StoredProcedure">
            <summary>
            Имя хранимой процедуры.
            </summary>
        </member>
        <member name="F:Nemiro.Data.TypeCommand.TableDirect">
            <summary>
            Имя таблицы.
            </summary>
        </member>
        <member name="F:Nemiro.Data.TypeCommand.Text">
            <summary>
            Запрос SQL.
            </summary>
        </member>
        <member name="T:Nemiro.Data.ColumnAttributeFlags">
            <summary>
            Перечень флагов, определяющих интерпретацию свойства при использовании в работаете с источником данных.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnAttributeFlags.None">
            <summary>
            Нет.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey">
            <summary>
            Ключевое поле.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnAttributeFlags.Identity">
            <summary>
            Счетчик, используется совместно с <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/>.
            </summary>
            <remarks>Данная опция указывает на то, что значение для поля будет присвоено автоматически.</remarks>
        </member>
        <member name="F:Nemiro.Data.ColumnAttributeFlags.AllowNull">
            <summary>
            Разрешить записывать <c>NULL</c>, при отсутствии значения.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnAttributeFlags.Unique">
            <summary>
            Указывает на то, что значение поля уникально и его можно использовать при проверке дубликатов записей.
            </summary>
        </member>
        <member name="T:Nemiro.Data.ColumnDefaultValues">
            <summary>
            Список динамичных значений по умолчанию для отправки в базу.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnDefaultValues.Now">
            <summary>
            Текущее дата и время.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnDefaultValues.NewId">
            <summary>
            Создать новый глобальный уникальный идентификатор <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="F:Nemiro.Data.ColumnDefaultValues.Empty">
            <summary>
            Пустое значение.
            </summary>
        </member>
        <member name="T:Nemiro.Data.OrderBy">
            <summary>
            Список вариантов сортировки.
            </summary>
        </member>
        <member name="F:Nemiro.Data.OrderBy.ASC">
            <summary>
            Сортировка по возрастанию.
            </summary>
        </member>
        <member name="F:Nemiro.Data.OrderBy.DESC">
            <summary>
            Сортировка по убыванию.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheCollection">
            <summary>
            Коллекция объектов управления кэшем.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheCollection.GetObjectCache(System.Type,System.Object[])">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования указанного типа.
            </summary>
            <param name="t">Тип кэша. Можно указать любой тип наследованный от <see cref="T:System.Runtime.Caching.ObjectCache"/>.</param>
            <param name="args">Дополнительные параметры, будут переданы в конструктор инициализации класса кэша. Важно соблюдать порядок элементов в массиве. Элементы массива будут переданы в параметры последовательно. Количество элементов массива должно соответствовать количеству параметров конструктора.</param>
        </member>
        <member name="T:Nemiro.Data.Caching.WebCache">
            <summary>
            Реализует стандартный веб-кэш.
            </summary>
            <remarks>
            <para>Этот класс является оберткой для стандартного кэша ASP .NET.</para>
            <para><see cref="T:Nemiro.Data.Caching.WebCache"/> предназначен только для использования в веб-проектах. В других типах проектов веб-кэш работать не будет.</para>
            <para>
            Кэширования является потокозависимым и не будет работать в отдельных потоках, только в основном.
            В качестве альтернативы, рекомендуется использовать универсальный, потоконезависимый <see cref="T:Nemiro.Data.Caching.FileCache"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.WebCache"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.#ctor(System.Web.HttpContext)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.WebCache"/> с указанием ссылки на конкретный <see cref="T:System.Web.HttpContext"/>.
            </summary>
            <param name="context">Экземпляр объекта <see cref="T:System.Web.HttpContext"/> для текущего HTTP-запроса.</param>
            <remarks>
            <para>
            Эту перегрузку можно использовать для реализации кэша в потоках. 
            Однако это будет неудобно, лучше использовать <see cref="T:Nemiro.Data.Caching.FileCache"/>.
            Либо реализовать самостоятельно доступ к <see cref="T:System.Web.Caching.Cache"/> из потоков.
            Последнее актуально только при отдельно использовании классов кэширования, без работы с базами данных.
            </para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            Вставляет запись в кэш, используя указанную пару "ключ-значение" и заданные сведения о методе её удаления.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, который требуется добавить.</param>
            <param name="value">Данные, который необходимо поместить в кэш.</param>
            <param name="policy">Объект, содержащий сведения о хранении данных в кэше.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша.</param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Добавляет запись в кэш, используя заданный экземпляр <see cref="T:System.Runtime.Caching.CacheItem"/> и сведения о способе удаления записи.
            </summary>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)">
            <summary>
            Добавляет запись в кэш, используя заданную пару "ключ-значение" и абсолютное значение срока действия.  
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="absoluteExpiration">Фиксированные дата и время истечения срока хранения записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша. </param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Contains(System.String,System.String)">
            <summary>
            Определяет, существует ли в кэше запись с указанным ключом.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <returns>Значение <c>True</c>, если в кэше содержится запись с указанным ключом; в противном случае — значение <c>False</c>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Создает объект <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor"/>, который может активировать события в ответ на изменения указанных записей кэша.
            </summary>
            <param name="keys">Уникальные идентификаторы записей кэша, которые необходимо отслеживать.</param>
            <param name="regionName">Именованная область кэша, в которой могут существовать ключи кэша в параметре <paramref name="keys"/>.</param>
            <returns>Монитор изменений, следящий за записями в кэше.</returns>
            <remarks>В текущей реализации данный метод не поддерживается.</remarks>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Get(System.String,System.String)">
            <summary>
            Получает из кэша указанную запись в виде объекта.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которой может находиться запись кэша.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.GetCacheItem(System.String,System.String)">
            <summary>
            Получает из кэша указанную запись в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/>.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которой может существовать ключ кэша, указанный в параметре <paramref name="key"/>.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.GetCount(System.String)">
            <summary>
            Получает общее число записей, находящихся в кэше.
            </summary>
            <param name="regionName">Именованная область кэша, для которой необходимо вычислить количество записей.</param>
            <returns>Число записей в кэше. Если значение <paramref name="regionName"/> не равно <c>null</c> (<c>Nothing</c>), 
            это число обозначает количество записей в указанной области кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.GetEnumerator">
            <summary>
            Создает перечислитель, который может использоваться для перебора записей кэша в коллекции.
            </summary>
            <returns>Объект перечислителя, предоставляющий доступ к записям кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Получает набор записей кэша, соответствующих указанным ключам.
            </summary>
            <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которую были добавлены одна или несколько записей кэша.</param>
            <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Remove(System.String,System.String)">
            <summary>
            Удаляет запись из кэша.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша, которую требуется удалить.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <returns>Объект, представляющий значение удаленной записи кэша, заданной данным ключом, или значение <c>null</c> (<c>Nothing</c>), если заданная запись не найдена.</returns>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            Вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/> и задает сведения о способе удаления записи.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            Вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem"/> и задает сведения о способе удаления записи.
            </summary>
            <param name="item">Данные, которые нужно поместить в кэш.</param>
            <param name="policy">Объект, содержащий сведения о хранении записи кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.WebCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)">
            <summary>
            Вставляет запись в кэш.
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую была добавлена запись кэша.</param>
            <param name="value">Данные, которые нужно поместить в кэш.</param>
            <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        </member>
        <member name="P:Nemiro.Data.Caching.WebCache.DefaultPolicy">
            <summary>
            Политика кэширования по умолчанию.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.WebCache.DefaultCacheCapabilities">
            <summary>
            Содержит описание функций, предоставляемых реализацией кэша.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.WebCache.Name">
            <summary>
            Имя экземпляра.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.WebCache.Item(System.String)">
            <summary>
            Возвращает запись кэша с указанным ключом. Если записи нет, возвращает <c>null</c> (<c>Nothing</c>).
            </summary>
            <param name="key">Уникальный идентификатор записи кэша.</param>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheBinder">
             <summary>
             Реализует привязку объекта сериализации к типу.
             </summary>
             <remarks>
             <para>Этот класс используется по умолчению при сериализации данных в файловом кэше (<see cref="T:Nemiro.Data.Caching.FileCache"/>).</para>
             </remarks>
             <example>
             <para>В следующем примере показан примерный код класса <see cref="T:Nemiro.Data.Caching.CacheBinder"/>.</para>
             <para>Вы можете реализовать в своем проекте свой <see cref="T:Nemiro.Data.Caching.CacheBinder"/>, просто скопировав этот код.</para>
             <code lang="C#">
             using System.Reflection;
             
             public sealed class MyCacheBinder : System.Runtime.Serialization.SerializationBinder
             {
            
               public override Type BindToType(string assemblyName, string typeName)
               {
                 return Type.GetType(String.Format("{0}, {1}", typeName, Assembly.GetExecutingAssembly().FullName));
               }
               
             }
             </code>
             <code lang="VB">
             Imports System.Reflection
             
             Public NotInheritable Class MyCacheBinder 
               Inherits System.Runtime.Serialization.SerializationBinder
            
               Public Overloads Overrides Function BindToType(assemblyName As String, typeName As String) As Type
                 Return Type.GetType(String.Format("{0}, {1}", typeName, Assembly.GetExecutingAssembly().FullName))
               End Function
               
             End Class
             </code>
             </example>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheBinder.BindToType(System.String,System.String)">
            <summary>
            Управляет привязкой сериализованного объекта к типу.
            </summary>
            <param name="assemblyName">Задает имя <see cref="T:System.Reflection.Assembly"/> сериализованного объекта.</param>
            <param name="typeName">Задает имя <see cref="T:System.Type"/> сериализованного объекта.</param>
            <returns>Тип объекта, новый экземпляр которого создает форматер.</returns>
        </member>
        <member name="T:Nemiro.Data.ValueForIdentityException">
            <summary>
            Данное исключение происходит, если у ключевого свойства отсутствует флаг <see cref="F:Nemiro.Data.ColumnAttributeFlags.Identity"/> и при этом соответствующее поле таблицы является числовым счетчиком.
            </summary>
            <remarks>Чтобы исправить эту ошибку, необходимо добавить ключевому свойству флаг <see cref="F:Nemiro.Data.ColumnAttributeFlags.Identity"/>.</remarks>
            <example>
            <code lang="C#">
            [Column("id", SqlDbType.Int, ColumnAttributeFlags.PrimaryKey | ColumnAttributeFlags.Identity)]
            public int ID { get; set; }
            </code>
            <code lang="VB">
            &lt;Column("id", SqlDbType.Int, ColumnAttributeFlags.PrimaryKey Or ColumnAttributeFlags.Identity)&gt; _
            Public Property ID() As Integer
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.ValueForIdentityException.#ctor(System.Exception)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.ValueForIdentityException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Sql.SqlType">
            <summary>
            Вспомогательный класс для работы с типами данных SQL Server.
            </summary>
            <remarks>
            <para>Этот класс используется для внутренних нужд библиотеки, но возможно он будет полезен и для решения каких-нибудь ваших задач.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlType.ConvertToSqlDbType(System.Type,System.Version)">
            <summary>
            Преобразует указанный тип .NET в тип SQL Server.
            </summary>
            <param name="t">Тип .NET, который нужно конвертировать в тип SQL Server.</param>
            <param name="version">Версия SQL Server.</param>
            <example>
            <code lang="C#">
            SqlDbType result = SqlType.ConvertToSqlDbType(typeof(long));
            Console.WriteLine("Тип данных SQL Server: {0}", result.ToString());
            </code>
            <code lang="VB">
            Dim result As SqlDbType = SqlType.ConvertToSqlDbType(GetType(Long))
            Console.WriteLine("Тип данных SQL Server: {0}", result.ToString())
            </code>
            </example>
            <returns>
            <para>Если указанный <paramref name="t"/> невозможно преобразовать в тип SQL Server, функция возвращает <see cref="F:System.Data.SqlDbType.Variant"/>.</para>
            </returns>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlType.IsStringType(System.Data.SqlDbType)">
            <summary>
            Проверяет, является ли указанный тип данных SQL Server строковым типом или нет.
            </summary>
            <param name="t">Тип данных SQL Server.</param>
            <returns>Возвращает <c>True</c>, если указанный тип данных SQL Server является строковым. В противном случае функция возвращает <c>False</c>.</returns>
            <remarks>
            <para>Проверка проводится по списку типов, указанном в свойстве <see cref="P:Nemiro.Data.Sql.SqlType.StringTypeList"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlType.IsNumericType(System.Data.SqlDbType)">
            <summary>
            Проверяет, является ли указанный тип данных SQL Server числовым типом или нет.
            </summary>
            <param name="t">Тип данных SQL Server.</param>
            <returns>Возвращает <c>True</c>, если указанный тип данных SQL Server является числовым. В противном случае функция возвращает <c>False</c>.</returns>
            <remarks>
            <para>Проверка проводится по списку типов, указанном в свойстве <see cref="P:Nemiro.Data.Sql.SqlType.NumericTypeList"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlType.IsDateType(System.Data.SqlDbType)">
            <summary>
            Проверяет, является ли указанный тип данных SQL Server датой или временем.
            </summary>
            <param name="t">Тип данных SQL Server.</param>
            <returns>Возвращает <c>True</c>, если указанный тип данных SQL Server является датой или временем. В противном случае функция возвращает <c>False</c>.</returns>
            <remarks>
            <para>Проверка проводится по списку типов, указанном в свойстве <see cref="P:Nemiro.Data.Sql.SqlType.DateTypeList"/>.</para>
            </remarks>
        </member>
        <member name="M:Nemiro.Data.Sql.SqlType.IsGuidType(System.Data.SqlDbType)">
            <summary>
            Проверяет, является ли указанный тип данных SQL Server глобальным уникальным идентификатором (<see cref="T:System.Guid"/>).
            </summary>
            <param name="t">Тип данных SQL Server.</param>
            <returns>Возвращает <c>True</c>, если указанный тип данных SQL Server является <see cref="T:System.Guid"/>. В противном случае функция возвращает <c>False</c>.</returns>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlType.StringTypeList">
            <summary>
            Перечь строковых типов данных SQL Server.
            </summary>
            <remarks>
            <para>
            В состав списка строковых типов данных входят:
            <list type="bullet">
            <item><description>SqlDbType.VarChar</description></item>
            <item><description>SqlDbType.NVarChar</description></item>
            <item><description>SqlDbType.Text</description></item>
            <item><description>SqlDbType.NText</description></item>
            <item><description>SqlDbType.Char</description></item>
            <item><description>SqlDbType.NChar</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlType.NumericTypeList">
            <summary>
            Перечь числовых типов данных SQL Server.
            </summary>
            <remarks>
            <para>
            В состав списка числовых типов данных входят:
            <list type="bullet">
            <item><description>SqlDbType.Int</description></item>
            <item><description>SqlDbType.BigInt</description></item>
            <item><description>SqlDbType.Float</description></item>
            <item><description>SqlDbType.Money</description></item>
            <item><description>SqlDbType.SmallInt</description></item>
            <item><description>SqlDbType.SmallMoney</description></item>
            <item><description>SqlDbType.TinyInt</description></item>
            <item><description>SqlDbType.Real</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Sql.SqlType.DateTypeList">
            <summary>
            Перечь типов данных дат и времени.
            </summary>
            <remarks>
            <para>
            В состав списка типов данных дат и времени входят:
            <list type="bullet">
            <item><description>SqlDbType.Date</description></item>
            <item><description>SqlDbType.DateTime</description></item>
            <item><description>SqlDbType.DateTime2</description></item>
            <item><description>SqlDbType.DateTimeOffset</description></item>
            <item><description>SqlDbType.SmallDateTime</description></item>
            <item><description>SqlDbType.Time</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:Nemiro.Data.DataChangeInfoCollection">
            <summary>
            Коллекция информации об изменении данных.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DataChangeInfoCollection.Add(System.String,System.String,System.String,System.Object,System.Object)">
            <summary>
            Добавляет информацию об изменении данных в коллекцию.
            </summary>
            <param name="previousValue">Предыдущее значение.</param>
            <param name="currentValue">Текущее значение.</param>
            <param name="columnName">Имя измененного поля таблицы.</param>
            <param name="propertyName">Имя измененного свойства.</param>
            <param name="displayName">Отображаемое имя.</param>
        </member>
        <member name="T:Nemiro.Data.Caching.SerializableDataRow">
            <summary>
            Реализует сериализуемый <see cref="T:System.Data.DataRow"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataRow.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataRow"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataRow.#ctor(System.Data.DataRow)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataRow"/>.
            </summary>
            <param name="row"></param>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataRow.GetDataRow">
            <summary>
            Конвертирует текущий экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataRow"/> в <see cref="T:System.Data.DataRow"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nemiro.Data.Caching.SerializableDataRow.ItemArray">
            <summary>
            Массив значений полей.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.SerializableDataRow.TableName">
            <summary>
            Имя таблицы.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.SerializableDataRow.Columns">
            <summary>
            Коллекция сериализуемых колонок таблицы.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.SerializableDataColumn">
            <summary>
            Реализует сериализуемый <see cref="T:System.Data.DataColumn"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataColumn.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataColumn"/>.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.SerializableDataColumn.#ctor(System.Data.DataColumn)">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataColumn"/>.
            </summary>
            <param name="c">Колонка, на основе которой будет построен экземпляр класса <see cref="T:Nemiro.Data.Caching.SerializableDataColumn"/>.</param>
        </member>
        <member name="P:Nemiro.Data.Caching.SerializableDataColumn.ColumnName">
            <summary>
            Мя колонки.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.SerializableDataColumn.DataType">
            <summary>
            Тип данных.
            </summary>
        </member>
        <member name="T:Nemiro.Data.Caching.CacheManager">
            <summary>
            Менеджер управления объектами кэширования и кэшем.
            Упрощает доступ к реализации кэша и содержит готовую логику использования кэша.
            </summary>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.GetObjectCache(System.Type,System.Object[])">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования указанного типа.
            </summary>
            <param name="t">Тип кэша. Можно указать любой тип наследованный от <see cref="T:System.Runtime.Caching.ObjectCache"/>.</param>
            <param name="args">Дополнительные параметры, будут переданы в конструктор инициализации класса кэша. Важно соблюдать порядок элементов в массиве. Элементы массива будут переданы в параметры последовательно. Количество элементов массива должно соответствовать количеству параметров конструктора.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.GetFileCache(System.String)">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования в файловой системе.
            </summary>
            <param name="cachePath">Физический путь расположения файлов кэша.</param>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.Add(System.Runtime.Caching.ObjectCache,System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            Добавляет запись в кэш.
            </summary>
            <param name="cache">Объект для доступа к кэшу.</param>
            <param name="key">Уникальный идентификатор записи кэша, который требуется добавить или получить.</param>
            <param name="value">Данные для записи кэша.</param>
            <param name="policy">Объект, содержащий сведения ою условиях хранения записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша. </param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="cache"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.Add(System.Runtime.Caching.ObjectCache,System.String,System.Object,System.DateTimeOffset,System.String)">
            <summary>
            Добавляет запись в кэш, используя заданную пару "ключ-значение" и абсолютное значение срока действия.  
            </summary>
            <param name="cache">Объект для доступа к кэшу.</param>
            <param name="key">Уникальный идентификатор записи кэша, который необходимо добавить.</param>
            <param name="value">Данные для записи кэша.</param>
            <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
            <param name="regionName">Именованная область кэша, в которую может быть добавлена запись кэша. </param>
            <returns>Существующая запись кэша, если существует запись кэша с таким же ключом; в противном случае — значение <c>null</c> (<c>Nothing</c>).</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="cache"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.Get(System.Runtime.Caching.ObjectCache,System.String,System.String)">
            <summary>
            Получает из кэша указанную запись в виде объекта.
            </summary>
            <param name="cache">Объект для доступа к кэшу.</param>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо получить.</param>
            <param name="regionName">Именованная область кэша, в которой может находиться ключ кэша.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="cache"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
        </member>
        <member name="M:Nemiro.Data.Caching.CacheManager.Remove(System.Runtime.Caching.ObjectCache,System.String,System.String)">
            <summary>
            Удаляет запись из кэша.
            </summary>
            <param name="cache">Объект для доступа к кэшу.</param>
            <param name="key">Уникальный идентификатор записи кэша, которую необходимо удалить.</param>
            <param name="regionName">Именованная область кэша, в которой может находиться ключ кэша.</param>
            <returns>Запись кэша, определяемая ключом <paramref name="key"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="cache"/> имеет значение <c>null</c> (<c>Nothing</c>).</exception>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheManager.Items">
            <summary>
            Коллекция кэшей приложения.
            </summary>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheManager.FileCache">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования в файловой системе, с путем по умолчанию.
            </summary>
            <remarks>Если нужен особый путь хранения файлов кэша, используйте метод <see cref="M:Nemiro.Data.Caching.CacheManager.GetFileCache(System.String)"/>.</remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheManager.MemoryCache">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования в памяти.
            </summary>
            <remarks>
            <para>Не рекомендуется использовать <see cref="P:Nemiro.Data.Caching.CacheManager.MemoryCache"/> в веб-проектах. 
            Из-за особенностей работы рабочих процессов IIS, <see cref="P:Nemiro.Data.Caching.CacheManager.MemoryCache"/> может быть нестабильным.</para>
            </remarks>
        </member>
        <member name="P:Nemiro.Data.Caching.CacheManager.WebCache">
            <summary>
            Возвращает, либо добавляет и возвращает объект кэширования ASP .NET.
            </summary>
            <remarks>
            <para>Используется стандартный кэш ASP .NET.</para>
            <para>Этот механизм кэширования не будет работать в приложениях Windows.</para>
            <para>Если у вас многопоточное приложение и в отдельных потоках требуется кэширование данных, лучше используйте файловый кэш,
            т.к. веб-кэш не приспособлен для работы в потоках.</para>
            </remarks>
        </member>
        <member name="T:Nemiro.Data.DataChangeLogger">
            <summary>
            Базовый класс для реализации функционала по ведению журнала изменений данных.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DataChangeLogger.#ctor(System.Object,System.Data.DataRow,System.String[])">
            <summary>
            Инициализирует новый экземпляр журнала изменений.
            </summary>
            <param name="owner">Ссылка на объект-владельца, изменения в котором нужно фиксировать.</param>
            <param name="sourceRow">Исходная строка данных, из который был создан объект-владелец.</param>
            <param name="monitoringFields">Список полей (свойств), изменения которых нужно отслеживать.</param>
        </member>
        <member name="M:Nemiro.Data.DataChangeLogger.Commit">
            <summary>
            Заносит изменения в журнал.
            </summary>
        </member>
        <member name="M:Nemiro.Data.DataChangeLogger.GetChanges">
            <summary>
            Возвращает информацию об изменении значений отслеживаемых полей.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeLogger.Owner">
            <summary>
            Ссылка на владельца журнала изменений.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeLogger.SourceRow">
            <summary>
            Исходная строка данных.
            </summary>
        </member>
        <member name="P:Nemiro.Data.DataChangeLogger.MonitoringFields">
            <summary>
            Список полей (свойств), изменения которых отслеживаются.
            </summary>
        </member>
        <member name="T:Nemiro.Data.NoTableAttributeException">
            <summary>
            Исключение возникает, если у класса, реализующего таблицу базы данных, отсутствует атрибут <see cref="T:Nemiro.Data.TableAttribute"/>.
            </summary>
            <remarks>Для исправления исключения необходимо добавить атрибут <see cref="T:Nemiro.Data.TableAttribute"/> к классу.</remarks>
            <example>
            <code lang="C#">
            [Table("example")]
            class Example : BaseObject
            { }
            </code>
            <code lang="VB">
            &lt;Table("example")&gt;
            Public Class Example 
              Inherits BaseObject
            End Class
            </code>
            </example>
        </member>
        <member name="M:Nemiro.Data.NoTableAttributeException.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.NoTableAttributeException"/>.
            </summary>
        </member>
        <member name="T:Nemiro.Data.MoreThanOnePrimaryKeyException">
            <summary>
            Исключение возникает, если в классе обнаружено более одного свойства с флагом <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/>.
            </summary>
            <remarks>Чтобы исправить ошибку, оставьте в классе только одно свойство с флагом <see cref="F:Nemiro.Data.ColumnAttributeFlags.PrimaryKey"/>.</remarks>
        </member>
        <member name="M:Nemiro.Data.MoreThanOnePrimaryKeyException.#ctor">
            <summary>
            Инициализирует новый экземпляр класса <see cref="T:Nemiro.Data.MoreThanOnePrimaryKeyException"/>.
            </summary>
        </member>
    </members>
</doc>
